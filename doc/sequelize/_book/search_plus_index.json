{"./":{"url":"./","title":"Introduction","keywords":"","body":"Sequelize Docs 中文版 此项目同步自 sequelize / sequelize 项目中的 docs. 更新日志请参阅: CHANGELOG Sequelize 是一个基于 promise 的 Node.js ORM 工具, 目前支持 Postgres, MySQL, MariaDB, SQLite 以及 Microsoft SQL Server, Amazon Redshift 和 Snowflake’s Data Cloud. 它具有强大的事务支持, 关联关系, 预读和延迟加载,读取复制等功能. Sequelize 遵从 语义版本控制 和 官方 Node.js LTS 版本. Sequelize v7 版本正式支持 Node.js ^12.22.0, ^14.17,0, ^16.0.0. 其他版本或可正常工作. 你目前正在查看 Sequelize 的教程和指南.你可能还对API 参考 (英文)感兴趣. 赞赏支持 文档版本 v7 中文文档(开发版本) v6 中文文档(保持更新) v5 中文文档(停止更新) v4 中文文档(停止更新) 主要版本变更日志 在此处可以找到主要版本的升级信息： 从 v5 升级到 v6 从 v6 升级到 v7 文档(v7) 核心概念 Getting Started - 入门 Model Basics - 模型基础 Model Instances - 模型实例 Model Querying - Basics - 模型查询(基础) Model Querying - Finders - 模型查询(查找器) Getters, Setters & Virtuals - 获取器, 设置器 & 虚拟字段 Validations & Constraints - 验证 & 约束 Raw Queries - 原始查询 Associations - 关联 Paranoid - 偏执表 高级关联概念 Eager Loading - 预先加载 Creating with Associations - 创建关联 Advanced M:N Associations - 高级 M:N 关联 Association Scopes - 关联作用域 Polymorphic Associations - 多态关联 其它主题 Dialect-Specific Things - 方言特定事项 Transactions - 事务 Hooks - 钩子 Query Interface - 查询接口 Naming Strategies - 命名策略 Scopes - 作用域 Sub Queries - 子查询 Other Data Types - 其他数据类型 Constraints & Circularities - 约束 & 循环 Extending Data Types - 扩展数据类型 Indexes - 索引 Optimistic Locking - 乐观锁定 Read Replication - 读取复制 Connection Pool - 连接池 Working with Legacy Tables - 使用遗留表 Migrations - 迁移 TypeScript Resources - 资源 安装 # 使用 npm npm i sequelize # 这将安装最新版本的 Sequelize # 使用 yarn yarn add sequelize # 用于支持数据库方言的库: # 使用 npm npm i pg pg-hstore # PostgreSQL npm i mysql2 # MySQL npm i mariadb # MariaDB npm i sqlite3 # SQLite npm i tedious # Microsoft SQL Server npm i ibm_db # DB2 # 使用 yarn yarn add pg pg-hstore # PostgreSQL yarn add mysql2 # MySQL yarn add mariadb # MariaDB yarn add sqlite3 # SQLite yarn add tedious # Microsoft SQL Server yarn add ibm_db # DB2 简单示例 const { Sequelize, Model, DataTypes } = require('sequelize'); const sequelize = new Sequelize('sqlite::memory:'); class User extends Model {} User.init({ username: DataTypes.STRING, birthday: DataTypes.DATE }, { sequelize, modelName: 'user' }); (async () => { await sequelize.sync(); const jane = await User.create({ username: 'janedoe', birthday: new Date(1980, 6, 20) }); console.log(jane.toJSON()); })(); 请通过 Getting started - 入门 来学习更多相关内容. 如果你想要学习 Sequelize API 请通过 API 参考 (英文). 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"core-concepts/getting-started.html":{"url":"core-concepts/getting-started.html","title":"Getting Started - 入门","keywords":"","body":"Getting Started - 入门 在本教程中,你将进行学习 Sequelize 的简单设置. 安装 Sequelize 的使用可以通过 npm (或 yarn). # 使用 npm npm i sequelize # 这将安装最新版本的 Sequelize # 使用 yarn yarn add sequelize 你还必须手动为所选数据库安装驱动程序： # 使用 npm npm i pg pg-hstore # PostgreSQL npm i mysql2 # MySQL npm i mariadb # MariaDB npm i sqlite3 # SQLite npm i tedious # Microsoft SQL Server npm i ibm_db # DB2 # 使用 yarn yarn add pg pg-hstore # PostgreSQL yarn add mysql2 # MySQL yarn add mariadb # MariaDB yarn add sqlite3 # SQLite yarn add tedious # Microsoft SQL Server yarn add ibm_db # DB2 连接到数据库 要连接到数据库,必须创建一个 Sequelize 实例. 这可以通过将连接参数分别传递到 Sequelize 构造函数或通过传递一个连接 URI 来完成： const { Sequelize } = require('sequelize'); // 方法 1: 传递一个连接 URI const sequelize = new Sequelize('sqlite::memory:') // Sqlite 示例 const sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname') // Postgres 示例 // 方法 2: 分别传递参数 (sqlite) const sequelize = new Sequelize({ dialect: 'sqlite', storage: 'path/to/database.sqlite' }); // 方法 3: 分别传递参数 (其它数据库) const sequelize = new Sequelize('database', 'username', 'password', { host: 'localhost', dialect: /* 选择 'mysql' | 'mariadb' | 'postgres' | 'mssql' 其一 */ }); Sequelize 构造函数接受很多参数. 它们记录在 API 参考中. 测试连接 你可以使用 .authenticate() 函数测试连接是否正常： try { await sequelize.authenticate(); console.log('Connection has been established successfully.'); } catch (error) { console.error('Unable to connect to the database:', error); } 关闭连接 默认情况下,Sequelize 将保持连接打开状态,并对所有查询使用相同的连接. 如果你需要关闭连接,请调用 sequelize.close()(这是异步的并返回一个 Promise). 术语约定 请注意,在上面的示例中,Sequelize 是指库本身,而 sequelize 是指 Sequelize 的实例,它表示与一个数据库的连接. 这是官方推荐的约定,在整个文档中都将遵循. 阅读文档的提示 我们鼓励你在阅读 Sequelize 文档时在本地运行代码示例. 这将帮助你更快地学习. 最简单的方法是使用 SQLite 方言： const { Sequelize, Op, Model, DataTypes } = require(\"sequelize\"); const sequelize = new Sequelize(\"sqlite::memory:\"); // 这是代码! 它是可用的! 要尝试使用在本地难以设置的其他方言,可以使用 Sequelize SSCCE GitHub 存储库,该库可让你在所有受支持的方言上运行代码, 直接从 GitHub 免费获得,无需任何设置！ 新数据库与现有数据库 如果你是从头开始一个项目,且你的数据库是空的,那么一开始就可以使用 Sequelize,以便自动创建数据库中的每个表. 除此之外,如果你想使用 Sequelize 连接到已经充满了表和数据的数据库,那也可以正常工作！ 在两种情况下,Sequelize 都能满足你的要求. 记录日志 默认情况下,Sequelize 将记录控制台执行的每个SQL查询. 可以使用 options.logging 参数来自定义每次 Sequelize 记录某些内容时将执行的函数. 默认值为 console.log,使用该值时仅显示日志函数调用的第一个参数. 例如,对于查询日志记录,第一个参数是原始查询,第二个参数(默认情况下是隐藏的)是 Sequelize 对象. options.logging 的常用值： const sequelize = new Sequelize('sqlite::memory:', { // 选择一种日志记录参数 logging: console.log, // 默认值,显示日志函数调用的第一个参数 logging: (...msg) => console.log(msg), // 显示所有日志函数调用参数 logging: false, // 禁用日志记录 logging: msg => logger.debug(msg), // 使用自定义记录器(例如Winston 或 Bunyan),显示第一个参数 logging: logger.debug.bind(logger) // 使用自定义记录器的另一种方法,显示所有消息 }); Promises 和 async/await Sequelize 提供的大多数方法都是异步的,因此返回 Promises. 它们都是 Promises, 因此你可以直接使用Promise API(例如,使用 then, catch, finally). 当然,使用 async 和 await 也可以正常工作. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"core-concepts/model-basics.html":{"url":"core-concepts/model-basics.html","title":"Model Basics - 模型基础","keywords":"","body":"Model Basics - 模型基础 在本教程中,你将学习 Sequelize 中的模型以及如何使用它们. 概念 模型是 Sequelize 的本质. 模型是代表数据库中表的抽象. 在 Sequelize 中,它是一个 Model 的扩展类. 该模型告诉 Sequelize 有关它代表的实体的几件事,例如数据库中表的名称以及它具有的列(及其数据类型). Sequelize 中的模型有一个名称. 此名称不必与它在数据库中表示的表的名称相同. 通常,模型具有单数名称(例如,User),而表具有复数名称(例如, Users),当然这是完全可配置的. 模型定义 在 Sequelize 中可以用两种等效的方式定义模型： 调用 sequelize.define(modelName, attributes, options) 扩展 Model 并调用 init(attributes, options) 定义模型后,可通过其模型名称在 sequelize.models 中使用该模型. 为了学习一个示例,我们将考虑创建一个代表用户的模型,该模型具有一个 firstName 和一个 lastName. 我们希望将模型称为 User,并将其表示的表在数据库中称为 Users. 定义该模型的两种方法如下所示. 定义后,我们可以使用 sequelize.models.User 访问模型. 使用 sequelize.define: const { Sequelize, DataTypes } = require('sequelize'); const sequelize = new Sequelize('sqlite::memory:'); const User = sequelize.define('User', { // 在这里定义模型属性 firstName: { type: DataTypes.STRING, allowNull: false }, lastName: { type: DataTypes.STRING // allowNull 默认为 true } }, { // 这是其他模型参数 }); // `sequelize.define` 会返回模型 console.log(User === sequelize.models.User); // true 扩展 Model const { Sequelize, DataTypes, Model } = require('sequelize'); const sequelize = new Sequelize('sqlite::memory:'); class User extends Model {} User.init({ // 在这里定义模型属性 firstName: { type: DataTypes.STRING, allowNull: false }, lastName: { type: DataTypes.STRING // allowNull 默认为 true } }, { // 这是其他模型参数 sequelize, // 我们需要传递连接实例 modelName: 'User' // 我们需要选择模型名称 }); // 定义的模型是类本身 console.log(User === sequelize.models.User); // true 在内部,sequelize.define 调用 Model.init,因此两种方法本质上是等效的. 公共类字段的注意事项 添加与模型属性之一同名的公共类字段会出现问题. Sequelize 为通过 Model.init 定义的每个属性添加一个 getter 和一个 setter. 添加公共类字段将隐藏那些 getter 和 setter，从而阻止对模型的实际数据的访问. // 无效的 class User extends Model { id; // 此字段将影响 sequelize 的 getter 和 setter. 它应该被删除. otherPublicField; // 这个字段不会影响任何东西. 没问题. } User.init({ id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true } }, { sequelize }); const user = new User({ id: 1 }); user.id; // undefined // 有效的 class User extends Model { otherPublicField; } User.init({ id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true } }, { sequelize }); const user = new User({ id: 1 }); user.id; // 1 在 TypeScript 中, 您可以使用 declare 关键字添加键入信息, 而无需添加实际的公共类字段: // 有效 class User extends Model { declare id: number; // 您可以使用 `declare` 关键字添加键入信息, 而无需添加实际的公共类字段. } User.init({ id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true } }, { sequelize }); const user = new User({ id: 1 }); user.id; // 1 表名推断 请注意,在以上两种方法中,都从未明确定义表名(Users). 但是,给出了模型名称(User). 默认情况下,当未提供表名时,Sequelize 会自动将模型名复数并将其用作表名. 这种复数是通过称为 inflection 的库在后台完成的,因此可以正确计算不规则的复数(例如 person -> people). 当然,此行为很容易配置. 强制表名称等于模型名称 你可以使用 freezeTableName: true 参数停止 Sequelize 执行自动复数化. 这样,Sequelize 将推断表名称等于模型名称,而无需进行任何修改： sequelize.define('User', { // ... (属性) }, { freezeTableName: true }); 上面的示例将创建一个名为 User 的模型,该模型指向一个也名为 User 的表. 也可以为 sequelize 实例全局定义此行为： const sequelize = new Sequelize('sqlite::memory:', { define: { freezeTableName: true } }); 这样,所有表将使用与模型名称相同的名称. 直接提供表名 你也可以直接直接告诉 Sequelize 表名称： sequelize.define('User', { // ... (属性) }, { tableName: 'Employees' }); 模型同步 定义模型时,你要告诉 Sequelize 有关数据库中表的一些信息. 但是,如果该表实际上不存在于数据库中怎么办？ 如果存在,但具有不同的列,较少的列或任何其他差异,该怎么办？ 这就是模型同步的来源.可以通过调用一个异步函数(返回一个Promise)model.sync(options). 通过此调用,Sequelize 将自动对数据库执行 SQL 查询. 请注意,这仅更改数据库中的表,而不更改 JavaScript 端的模型. User.sync() - 如果表不存在,则创建该表(如果已经存在,则不执行任何操作) User.sync({ force: true }) - 将创建表,如果表已经存在,则将其首先删除 User.sync({ alter: true }) - 这将检查数据库中表的当前状态(它具有哪些列,它们的数据类型等),然后在表中进行必要的更改以使其与模型匹配. 示例: await User.sync({ force: true }); console.log(\"用户模型表刚刚(重新)创建！\"); 一次同步所有模型 你可以使用 sequelize.sync() 自动同步所有模型. 示例： await sequelize.sync({ force: true }); console.log(\"所有模型均已成功同步.\"); 删除表 删除与模型相关的表： await User.drop(); console.log(\"用户表已删除!\"); 删除所有表： await sequelize.drop(); console.log(\"所有表已删除!\"); 数据库安全检查 如上所示,sync和drop操作是破坏性的. Sequelize 使用 match 参数作为附加的安全检查,该检查将接受 RegExp： // 仅当数据库名称以 '_test' 结尾时,它才会运行.sync() sequelize.sync({ force: true, match: /_test$/ }); 生产环境同步 如上所示,sync({ force: true }) 和 sync({ alter: true }) 可能是破坏性操作. 因此,不建议将它们用于生产级软件中. 相反,应该在 Sequelize CLI 的帮助下使用高级概念 Migrations(迁移) 进行同步. 时间戳 默认情况下,Sequelize 使用数据类型 DataTypes.DATE 自动向每个模型添加 createdAt 和 updatedAt 字段. 这些字段会自动进行管理 - 每当你使用Sequelize 创建或更新内容时,这些字段都会被自动设置. createdAt 字段将包含代表创建时刻的时间戳,而 updatedAt 字段将包含最新更新的时间戳. 注意： 这是在 Sequelize 级别完成的(即未使用 SQL触发器 完成). 这意味着直接 SQL 查询(例如,通过任何其他方式在不使用 Sequelize 的情况下执行的查询)将不会导致这些字段自动更新. 对于带有 timestamps: false 参数的模型,可以禁用此行为： sequelize.define('User', { // ... (属性) }, { timestamps: false }); 也可以只启用 createdAt/updatedAt 之一,并为这些列提供自定义名称： class Foo extends Model {} Foo.init({ /* 属性 */ }, { sequelize, // 不要忘记启用时间戳！ timestamps: true, // 不想要 createdAt createdAt: false, // 想要 updatedAt 但是希望名称叫做 updateTimestamp updatedAt: 'updateTimestamp' }); 列声明简写语法 如果关于列的唯一指定内容是其数据类型,则可以缩短语法： // 例如: sequelize.define('User', { name: { type: DataTypes.STRING } }); // 可以简写为: sequelize.define('User', { name: DataTypes.STRING }); 默认值 默认情况下,Sequelize 假定列的默认值为 NULL. 可以通过将特定的 defaultValue 传递给列定义来更改此行为： sequelize.define('User', { name: { type: DataTypes.STRING, defaultValue: \"John Doe\" } }); 一些特殊的值,例如 DataTypes.NOW,也能被接受： sequelize.define('Foo', { bar: { type: DataTypes.DATETIME, defaultValue: DataTypes.NOW // 这样,当前日期/时间将用于填充此列(在插入时) } }); 数据类型 你在模型中定义的每一列都必须具有数据类型. Sequelize 提供很多内置数据类型. 要访问内置数据类型,必须导入 DataTypes： const { DataTypes } = require(\"sequelize\"); // 导入内置数据类型 字符串 DataTypes.STRING // VARCHAR(255) DataTypes.STRING(1234) // VARCHAR(1234) DataTypes.STRING.BINARY // VARCHAR BINARY DataTypes.TEXT // TEXT DataTypes.TEXT('tiny') // TINYTEXT DataTypes.CITEXT // CITEXT 仅 PostgreSQL 和 SQLite. DataTypes.TSVECTOR // TSVECTOR 仅 PostgreSQL. 布尔 DataTypes.BOOLEAN // TINYINT(1) 数字 DataTypes.INTEGER // INTEGER DataTypes.BIGINT // BIGINT DataTypes.BIGINT(11) // BIGINT(11) DataTypes.FLOAT // FLOAT DataTypes.FLOAT(11) // FLOAT(11) DataTypes.FLOAT(11, 10) // FLOAT(11,10) DataTypes.REAL // REAL 仅 PostgreSQL. DataTypes.REAL(11) // REAL(11) 仅 PostgreSQL. DataTypes.REAL(11, 12) // REAL(11,12) 仅 PostgreSQL. DataTypes.DOUBLE // DOUBLE DataTypes.DOUBLE(11) // DOUBLE(11) DataTypes.DOUBLE(11, 10) // DOUBLE(11,10) DataTypes.DECIMAL // DECIMAL DataTypes.DECIMAL(10, 2) // DECIMAL(10,2) 无符号和零填充整数 - 仅限于MySQL/MariaDB 在 MySQL 和 MariaDB 中,可以将数据类型INTEGER, BIGINT, FLOAT 和 DOUBLE 设置为无符号或零填充(或两者),如下所示： DataTypes.INTEGER.UNSIGNED DataTypes.INTEGER.ZEROFILL DataTypes.INTEGER.UNSIGNED.ZEROFILL // 你还可以指定大小,即INTEGER(10)而不是简单的INTEGER // 同样适用于 BIGINT, FLOAT 和 DOUBLE 日期 DataTypes.DATE // DATETIME 适用于 mysql / sqlite, 带时区的TIMESTAMP 适用于 postgres DataTypes.DATE(6) // DATETIME(6) 适用于 mysql 5.6.4+. 支持6位精度的小数秒 DataTypes.DATEONLY // 不带时间的 DATE UUID 对于 UUID,使用 DataTypes.UUID. 对于 PostgreSQL 和 SQLite,它会是 UUID 数据类型;对于 MySQL,它则变成CHAR(36). Sequelize 可以自动为这些字段生成 UUID,只需使用 DataTypes.UUIDV1 或 DataTypes.UUIDV4 作为默认值即可： { type: DataTypes.UUID, defaultValue: DataTypes.UUIDV4 // 或 DataTypes.UUIDV1 } 其它 还有其他数据类型,请参见其它数据类型. 列参数 在定义列时,除了指定列的 type 以及上面提到的 allowNull 和 defaultValue 参数外,还有很多可用的参数. 下面是一些示例. const { Model, DataTypes, Deferrable } = require(\"sequelize\"); class Foo extends Model {} Foo.init({ // 实例化将自动将 flag 设置为 true (如果未设置) flag: { type: DataTypes.BOOLEAN, allowNull: false, defaultValue: true }, // 日期的默认值 => 当前时间 myDate: { type: DataTypes.DATE, defaultValue: DataTypes.NOW }, // 将 allowNull 设置为 false 将为该列添加 NOT NULL, // 这意味着如果该列为 null,则在执行查询时将从数据库引发错误. // 如果要在查询数据库之前检查值是否不为 null,请查看下面的验证部分. title: { type: DataTypes.STRING, allowNull: false }, // 创建两个具有相同值的对象将引发错误. // unique 属性可以是布尔值或字符串. // 如果为多个列提供相同的字符串,则它们将形成一个复合唯一键. uniqueOne: { type: DataTypes.STRING, unique: 'compositeIndex' }, uniqueTwo: { type: DataTypes.INTEGER, unique: 'compositeIndex' }, // unique 属性是创建唯一约束的简写. someUnique: { type: DataTypes.STRING, unique: true }, // 继续阅读有关主键的更多信息 identifier: { type: DataTypes.STRING, primaryKey: true }, // autoIncrement 可用于创建 auto_incrementing 整数列 incrementMe: { type: DataTypes.INTEGER, autoIncrement: true }, // 你可以通过 'field' 属性指定自定义列名称： fieldWithUnderscores: { type: DataTypes.STRING, field: 'field_with_underscores' }, // 可以创建外键： bar_id: { type: DataTypes.INTEGER, references: { // 这是对另一个模型的参考 model: Bar, // 这是引用模型的列名 key: 'id', // 使用 PostgreSQL,可以通过 Deferrable 类型声明何时检查外键约束. deferrable: Deferrable.INITIALLY_IMMEDIATE // 参数: // - `Deferrable.INITIALLY_IMMEDIATE` - 立即检查外键约束 // - `Deferrable.INITIALLY_DEFERRED` - 将所有外键约束检查推迟到事务结束 // - `Deferrable.NOT` - 完全不推迟检查(默认) - 这将不允许你动态更改事务中的规则 } }, // 注释只能添加到 MySQL,MariaDB,PostgreSQL 和 MSSQL 的列中 commentMe: { type: DataTypes.INTEGER, comment: '这是带有注释的列' } }, { sequelize, modelName: 'foo', // 在上面的属性中使用 `unique: true` 与在模型的参数中创建索引完全相同： indexes: [{ unique: true, fields: ['someUnique'] }] }); 利用模型作为类 Sequelize 模型是 ES6 类. 你可以非常轻松地添加自定义实例或类级别的方法. class User extends Model { static classLevelMethod() { return 'foo'; } instanceLevelMethod() { return 'bar'; } getFullname() { return [this.firstname, this.lastname].join(' '); } } User.init({ firstname: Sequelize.TEXT, lastname: Sequelize.TEXT }, { sequelize }); console.log(User.classLevelMethod()); // 'foo' const user = User.build({ firstname: 'Jane', lastname: 'Doe' }); console.log(user.instanceLevelMethod()); // 'bar' console.log(user.getFullname()); // 'Jane Doe' 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"core-concepts/model-instances.html":{"url":"core-concepts/model-instances.html","title":"Model Instances - 模型实例","keywords":"","body":"Model Instances - 模型实例 如你所知,模型是 ES6 类. 类的实例表示该模型中的一个对象(该对象映射到数据库中表的一行). 这样,模型实例就是 DAOs 对于本指南,将假定以下设置： const { Sequelize, Model, DataTypes } = require(\"sequelize\"); const sequelize = new Sequelize(\"sqlite::memory:\"); const User = sequelize.define(\"user\", { name: DataTypes.TEXT, favoriteColor: { type: DataTypes.TEXT, defaultValue: 'green' }, age: DataTypes.INTEGER, cash: DataTypes.INTEGER }); (async () => { await sequelize.sync({ force: true }); // 这里是代码 })(); 创建实例 尽管模型是一个类,但是你不应直接使用 new 运算符来创建实例. 相反,应该使用 build 方法： const jane = User.build({ name: \"Jane\" }); console.log(jane instanceof User); // true console.log(jane.name); // \"Jane\" 但是,以上代码根本无法与数据库通信(请注意,它甚至不是异步的)！ 这是因为 build 方法仅创建一个对象,该对象 表示 可以 映射到数据库的数据. 为了将这个实例真正保存(即持久保存)在数据库中,应使用 save 方法： await jane.save(); console.log('Jane 已保存到数据库!'); 请注意,从上面代码段中的 await 用法来看,save 是一种异步方法. 实际上,几乎每个 Sequelize 方法都是异步的. build 是极少数例外之一. 非常有用的捷径: create 方法 Sequelize提供了 create 方法,该方法将上述的 build 方法和 save 方法合并为一个方法： const jane = await User.create({ name: \"Jane\" }); // Jane 现在存在于数据库中！ console.log(jane instanceof User); // true console.log(jane.name); // \"Jane\" 注意: 实例记录 尝试将模型实例直接记录到 console.log 会产生很多问题,因为 Sequelize 实例具有很多附加条件. 相反,你可以使用 .toJSON() 方法(顺便说一句,它会自动保证实例被 JSON.stringify 编辑好). const jane = await User.create({ name: \"Jane\" }); // console.log(jane); // 不要这样! console.log(jane.toJSON()); // 这样最好! console.log(JSON.stringify(jane, null, 4)); // 这样也不错! 默认值 内置实例将自动获得默认值： const jane = User.build({ name: \"Jane\" }); console.log(jane.favoriteColor); // \"green\" 更新实例 如果你更改实例的某个字段的值,则再次调用 save 将相应地对其进行更新： const jane = await User.create({ name: \"Jane\" }); console.log(jane.name); // \"Jane\" jane.name = \"Ada\"; // 数据库中的名称仍然是 \"Jane\" await jane.save(); // 现在该名称已在数据库中更新为 \"Ada\"！ 您可以使用 set 方法一次更新多个字段: const jane = await User.create({ name: \"Jane\" }); jane.set({ name: \"Ada\", favoriteColor: \"blue\" }); // 如上, 数据库中还是 \"Jane\" 和 \"green\" await jane.save(); // 数据库现在将 \"Ada\" 和 \"blue\" 作为 name 和 favoriteColor 请注意, 此处的 save() 也将保留在此实例上所做的任何其他更改, 而不仅仅是之前的 set 调用中的更改.如果要更新一组特定的字段, 可以使用update: const jane = await User.create({ name: \"Jane\" }); jane.favoriteColor = \"blue\" await jane.update({ name: \"Ada\" }) // 数据库现在将 \"Ada\" 作为 name，但仍然有默认的 \"green\" 作为 favoriteColor await jane.save() // 数据库现在将 \"Ada\" 作为 name，但仍然有默认的 \"blue\" 作为 favoriteColor 删除实例 你可以通过调用 destroy 来删除实例: const jane = await User.create({ name: \"Jane\" }); console.log(jane.name); // \"Jane\" await jane.destroy(); // 现在该条目已从数据库中删除 重载实例 你可以通过调用 reload 从数据库中重新加载实例: const jane = await User.create({ name: \"Jane\" }); console.log(jane.name); // \"Jane\" jane.name = \"Ada\"; // 数据库中的名称依然是 \"Jane\" await jane.reload(); console.log(jane.name); // \"Jane\" reload 调用生成一个 SELECT 查询,以从数据库中获取最新数据. 仅保存部分字段 通过传递一个列名数组,可以定义在调用 save 时应该保存哪些属性. 当你基于先前定义的对象设置属性时,例如,当你通过 Web 应用程序的形式获取对象的值时,这很有用. 此外,这在 update 实现中内部使用. 它是这样的： const jane = await User.create({ name: \"Jane\" }); console.log(jane.name); // \"Jane\" console.log(jane.favoriteColor); // \"green\" jane.name = \"Jane II\"; jane.favoriteColor = \"blue\"; await jane.save({ fields: ['name'] }); console.log(jane.name); // \"Jane II\" console.log(jane.favoriteColor); // \"blue\" // 上面显示为 \"blue\",因为本地对象将其设置为 \"blue\", // 但是在数据库中它仍然是 \"green\"： await jane.reload(); console.log(jane.name); // \"Jane II\" console.log(jane.favoriteColor); // \"green\" Change-awareness of save The save method is optimized internally to only update fields that really changed. This means that if you don't change anything and call save, Sequelize will know that the save is superfluous and do nothing, i.e., no query will be generated (it will still return a Promise, but it will resolve immediately). Also, if only a few attributes have changed when you call save, only those fields will be sent in the UPDATE query, to improve performance. 递增和递减整数值 为了递增/递减实例的值而不会遇到并发问题,Sequelize提供了 increment 和 decrement 实例方法. const jane = await User.create({ name: \"Jane\", age: 100 }); const incrementResult = await jane.increment('age', { by: 2 }); // 注意: 如只增加 1, 你可以省略 'by' 参数, 只需执行 `user.increment('age')` // 在 PostgreSQL 中, 除非设置了 `{returning：false}` 参数(不然它将是 undefined), // 否则 `incrementResult` 将是更新后的 user. // 在其它数据库方言中, `incrementResult` 将会是 undefined. 如果你需要更新的实例, 你需要调用 `user.reload()`. 你也可以一次递增多个字段： const jane = await User.create({ name: \"Jane\", age: 100, cash: 5000 }); await jane.increment({ 'age': 2, 'cash': 100 }); // 如果值增加相同的数量,则也可以使用以下其他语法： await jane.increment(['age', 'cash'], { by: 2 }); 递减的工作原理完全相同. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"core-concepts/model-querying-basics.html":{"url":"core-concepts/model-querying-basics.html","title":"Model Querying - Basics - 模型查询(基础)","keywords":"","body":"Model Querying - Basics - 模型查询(基础) Sequelize 提供了多种方法来协助查询数据库中的数据. 重要说明：要使用 Sequelize 执行生产级别的查询,请确保你还阅读了事务指南. 事务对于确保数据完整性和提供其它好处很重要. 本指南将说明如何进行标准的 增删改查(CRUD) 查询. 简单 INSERT 查询 首先,一个简单的例子： // 创建一个新用户 const jane = await User.create({ firstName: \"Jane\", lastName: \"Doe\" }); console.log(\"Jane's auto-generated ID:\", jane.id); Model.create() 方法是使用 Model.build() 构建未保存实例并使用 instance.save() 保存实例的简写形式. 也可以定义在 create 方法中的属性. 如果你基于用户填写的表单创建数据库条目,这将特别有用. 例如,使用它可以允许你将 User 模型限制为仅设置用户名和地址,而不设置管理员标志 (例如, isAdmin)： const user = await User.create({ username: 'alice123', isAdmin: true }, { fields: ['username'] }); // 假设 isAdmin 的默认值为 false console.log(user.username); // 'alice123' console.log(user.isAdmin); // false 简单 SELECT 查询 你可以使用 findAll 方法从数据库中读取整个表： // 查询所有用户 const users = await User.findAll(); console.log(users.every(user => user instanceof User)); // true console.log(\"All users:\", JSON.stringify(users, null, 2)); SELECT * FROM ... SELECT 查询特定属性 选择某些特定属性,可以使用 attributes 参数： Model.findAll({ attributes: ['foo', 'bar'] }); SELECT foo, bar FROM ... 可以使用嵌套数组来重命名属性： Model.findAll({ attributes: ['foo', ['bar', 'baz'], 'qux'] }); SELECT foo, bar AS baz, qux FROM ... 你可以使用 sequelize.fn 进行聚合： Model.findAll({ attributes: [ 'foo', [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats'], 'bar' ] }); SELECT foo, COUNT(hats) AS n_hats, bar FROM ... 使用聚合函数时,必须为它提供一个别名,以便能够从模型中访问它. 在上面的示例中,你可以通过 instance.n_hats 获取帽子数量. 有时,如果只想添加聚合,那么列出模型的所有属性可能会很麻烦： // 这是获取帽子数量的烦人方法(每列都有) Model.findAll({ attributes: [ 'id', 'foo', 'bar', 'baz', 'qux', 'hats', // 我们必须列出所有属性... [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats'] // 添加聚合... ] }); // 这个更短,并且更不易出错. 如果以后在模型中添加/删除属性,它仍然可以正常工作 Model.findAll({ attributes: { include: [ [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats'] ] } }); SELECT id, foo, bar, baz, qux, hats, COUNT(hats) AS n_hats FROM ... 同样,也可以排除某些属性： Model.findAll({ attributes: { exclude: ['baz'] } }); -- Assuming all columns are 'id', 'foo', 'bar', 'baz' and 'qux' SELECT id, foo, bar, qux FROM ... 应用 WHERE 子句 where 参数用于过滤查询.where 子句有很多运算符,可以从 Op 中以 Symbols 的形式使用. 基础 Post.findAll({ where: { authorId: 2 } }); // SELECT * FROM post WHERE authorId = 2; 可以看到没有显式传递任何运算符(来自Op),因为默认情况下 Sequelize 假定进行相等比较. 上面的代码等效于： const { Op } = require(\"sequelize\"); Post.findAll({ where: { authorId: { [Op.eq]: 2 } } }); // SELECT * FROM post WHERE authorId = 2; 可以传递多个校验: Post.findAll({ where: { authorId: 12, status: 'active' } }); // SELECT * FROM post WHERE authorId = 12 AND status = 'active'; 就像在第一个示例中 Sequelize 推断出 Op.eq 运算符一样,在这里 Sequelize 推断出调用者希望对两个检查使用 AND. 上面的代码等效于： const { Op } = require(\"sequelize\"); Post.findAll({ where: { [Op.and]: [ { authorId: 12 }, { status: 'active' } ] } }); // SELECT * FROM post WHERE authorId = 12 AND status = 'active'; OR 可以通过类似的方式轻松执行： const { Op } = require(\"sequelize\"); Post.findAll({ where: { [Op.or]: [ { authorId: 12 }, { authorId: 13 } ] } }); // SELECT * FROM post WHERE authorId = 12 OR authorId = 13; 由于以上的 OR 涉及相同字段 ,因此 Sequelize 允许你使用稍有不同的结构,该结构更易读并且作用相同： const { Op } = require(\"sequelize\"); Post.destroy({ where: { authorId: { [Op.or]: [12, 13] } } }); // DELETE FROM post WHERE authorId = 12 OR authorId = 13; 操作符 Sequelize 提供了多种运算符. const { Op } = require(\"sequelize\"); Post.findAll({ where: { [Op.and]: [{ a: 5 }, { b: 6 }], // (a = 5) AND (b = 6) [Op.or]: [{ a: 5 }, { b: 6 }], // (a = 5) OR (b = 6) someAttribute: { // 基本 [Op.eq]: 3, // = 3 [Op.ne]: 20, // != 20 [Op.is]: null, // IS NULL [Op.not]: true, // IS NOT TRUE [Op.or]: [5, 6], // (someAttribute = 5) OR (someAttribute = 6) // 使用方言特定的列标识符 (以下示例中使用 PG): [Op.col]: 'user.organization_id', // = \"user\".\"organization_id\" // 数字比较 [Op.gt]: 6, // > 6 [Op.gte]: 6, // >= 6 [Op.lt]: 10, // ALL (SELECT 1) [Op.in]: [1, 2], // IN [1, 2] [Op.notIn]: [1, 2], // NOT IN [1, 2] [Op.like]: '%hat', // LIKE '%hat' [Op.notLike]: '%hat', // NOT LIKE '%hat' [Op.startsWith]: 'hat', // LIKE 'hat%' [Op.endsWith]: 'hat', // LIKE '%hat' [Op.substring]: 'hat', // LIKE '%hat%' [Op.iLike]: '%hat', // ILIKE '%hat' (不区分大小写) (仅 PG) [Op.notILike]: '%hat', // NOT ILIKE '%hat' (仅 PG) [Op.regexp]: '^[h|a|t]', // REGEXP/~ '^[h|a|t]' (仅 MySQL/PG) [Op.notRegexp]: '^[h|a|t]', // NOT REGEXP/!~ '^[h|a|t]' (仅 MySQL/PG) [Op.iRegexp]: '^[h|a|t]', // ~* '^[h|a|t]' (仅 PG) [Op.notIRegexp]: '^[h|a|t]', // !~* '^[h|a|t]' (仅 PG) [Op.any]: [2, 3], // ANY ARRAY[2, 3]::INTEGER (仅 PG) [Op.match]: Sequelize.fn('to_tsquery', 'fat & rat') // 匹配文本搜索字符串 'fat' 和 'rat' (仅 PG) // 在 Postgres 中, Op.like/Op.iLike/Op.notLike 可以结合 Op.any 使用: [Op.like]: { [Op.any]: ['cat', 'hat'] } // LIKE ANY ARRAY['cat', 'hat'] // 还有更多的仅限 postgres 的范围运算符,请参见下文 } } }); Op.in 的简写语法 直接将数组参数传递给 where 将隐式使用 IN 运算符： Post.findAll({ where: { id: [1,2,3] // 等同使用 `id: { [Op.in]: [1,2,3] }` } }); // SELECT ... FROM \"posts\" AS \"post\" WHERE \"post\".\"id\" IN (1, 2, 3); 运算符的逻辑组合 运算符 Op.and, Op.or 和 Op.not 可用于创建任意复杂的嵌套逻辑比较. 使用 Op.and 和 Op.or 示例 const { Op } = require(\"sequelize\"); Foo.findAll({ where: { rank: { [Op.or]: { [Op.lt]: 1000, [Op.eq]: null } }, // rank [timestamp] { [Op.or]: [ { title: { [Op.like]: 'Boat%' } }, { description: { [Op.like]: '%boat%' } } ] } // title LIKE 'Boat%' OR description LIKE '%boat%' } }); 使用 Op.not 示例 Project.findAll({ where: { name: 'Some Project', [Op.not]: [ { id: [1,2,3] }, { description: { [Op.like]: 'Hello%' } } ] } }); 上面将生成： SELECT * FROM `Projects` WHERE ( `Projects`.`name` = 'Some Project' AND NOT ( `Projects`.`id` IN (1,2,3) AND `Projects`.`description` LIKE 'Hello%' ) ) 高级查询(不仅限于列) 如果你想得到类似 WHERE char_length(\"content\") = 7 的结果怎么办？ Post.findAll({ where: sequelize.where(sequelize.fn('char_length', sequelize.col('content')), 7) }); // SELECT ... FROM \"posts\" AS \"post\" WHERE char_length(\"content\") = 7 请注意方法 sequelize.fn 和 sequelize.col 的用法,应分别用于指定 SQL 函数调用和列. 应该使用这些方法,而不是传递纯字符串(例如 char_length(content)),因为 Sequelize 需要以不同的方式对待这种情况(例如,使用其他符号转义方法). 如果你需要更复杂的东西怎么办？ Post.findAll({ where: { [Op.or]: [ sequelize.where(sequelize.fn('char_length', sequelize.col('content')), 7), { content: { [Op.like]: 'Hello%' } }, { [Op.and]: [ { status: 'draft' }, sequelize.where(sequelize.fn('char_length', sequelize.col('content')), { [Op.gt]: 10 }) ] } ] } }); 上面生成了以下SQL： SELECT ... FROM \"posts\" AS \"post\" WHERE ( char_length(\"content\") = 7 OR \"post\".\"content\" LIKE 'Hello%' OR ( \"post\".\"status\" = 'draft' AND char_length(\"content\") > 10 ) ) 仅限 Postgres 的范围运算符 可以使用所有支持的运算符查询范围类型. 请记住,提供的范围值也可以定义绑定的 包含/排除. [Op.contains]: 2, // @> '2'::integer (PG range 包含元素运算符) [Op.contains]: [1, 2], // @> [1, 2) (PG range 包含范围运算符) [Op.contained]: [1, 2], // > [1, 2) (PG range 右严格运算符) [Op.noExtendRight]: [1, 2], // & [1, 2) (PG range 未延伸到左侧运算符) 不推荐使用: 操作符别名 在 Sequelize v4 中,可以指定字符串来引用运算符,而不是使用 Symbols. 现在不建议使用此方法,很可能在下一个主要版本中将其删除. 如果确实需要,可以在 Sequelize 构造函数中传递 operatorAliases 参数. 例如: const { Sequelize, Op } = require(\"sequelize\"); const sequelize = new Sequelize('sqlite::memory:', { operatorsAliases: { $gt: Op.gt } }); // 现在我们可以在 where 子句中使用 `$gt` 代替 `[Op.gt]`： Foo.findAll({ where: { $gt: 6 // 就像使用 [Op.gt] } }); 简单 UPDATE 查询 Update 查询也接受 where 参数,就像上面的读取查询一样. // 将所有没有姓氏的人更改为 \"Doe\" await User.update({ lastName: \"Doe\" }, { where: { lastName: null } }); 简单 DELETE 查询 Delete 查询也接受 where 参数,就像上面的读取查询一样. // 删除所有名为 \"Jane\" 的人 await User.destroy({ where: { firstName: \"Jane\" } }); 要销毁所有内容,可以使用 TRUNCATE SQL： // 截断表格 await User.destroy({ truncate: true }); 批量创建 Sequelize 提供了 Model.bulkCreate 方法,以允许仅一次查询即可一次创建多个记录. 通过接收数组对象而不是单个对象,Model.bulkCreate 的用法与 Model.create 非常相似. const captains = await Captain.bulkCreate([ { name: 'Jack Sparrow' }, { name: 'Davy Jones' } ]); console.log(captains.length); // 2 console.log(captains[0] instanceof Captain); // true console.log(captains[0].name); // 'Jack Sparrow' console.log(captains[0].id); // 1 // (或另一个自动生成的值) 但是,默认情况下,bulkCreate 不会在要创建的每个对象上运行验证(而 create 可以做到). 为了使 bulkCreate 也运行这些验证,必须通过validate: true 参数. 但这会降低性能. 用法示例： const Foo = sequelize.define('foo', { bar: { type: DataTypes.TEXT, validate: { len: [4, 6] } } }); // 这不会引发错误,两个实例都将被创建 await Foo.bulkCreate([ { name: 'abc123' }, { name: 'name too long' } ]); // 这将引发错误,不会创建任何内容 await Foo.bulkCreate([ { name: 'abc123' }, { name: 'name too long' } ], { validate: true }); 如果你直接从用户获取值,那么限制实际插入的列可能会有所帮助. 为了做到这一点,bulkCreate() 接受一个 fields 参数,该参数须为你要定义字段的数组(其余字段将被忽略). await User.bulkCreate([ { username: 'foo' }, { username: 'bar', admin: true } ], { fields: ['username'] }); // foo 和 bar 都不会是管理员. 排序和分组 Sequelize 提供了 order and group 参数,来与 ORDER BY 和 GROUP BY 一起使用. 排序 order 参数采用一系列 项 来让 sequelize 方法对查询进行排序. 这些 项 本身是 [column, direction] 形式的数组. 该列将被正确转义,并且将在有效方向列表中进行验证(例如 ASC, DESC, NULLS FIRST 等). Subtask.findAll({ order: [ // 将转义 title 并针对有效方向列表进行降序排列 ['title', 'DESC'], // 将按最大年龄进行升序排序 sequelize.fn('max', sequelize.col('age')), // 将按最大年龄进行降序排序 [sequelize.fn('max', sequelize.col('age')), 'DESC'], // 将按 otherfunction(`col1`, 12, 'lalala') 进行降序排序 [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'], // 将使用模型名称作为关联名称按关联模型的 createdAt 排序. [Task, 'createdAt', 'DESC'], // 将使用模型名称作为关联名称通过关联模型的 createdAt 排序. [Task, Project, 'createdAt', 'DESC'], // 将使用关联名称按关联模型的 createdAt 排序. ['Task', 'createdAt', 'DESC'], // 将使用关联的名称按嵌套的关联模型的 createdAt 排序. ['Task', 'Project', 'createdAt', 'DESC'], // 将使用关联对象按关联模型的 createdAt 排序. (首选方法) [Subtask.associations.Task, 'createdAt', 'DESC'], // 将使用关联对象按嵌套关联模型的 createdAt 排序. (首选方法) [Subtask.associations.Task, Task.associations.Project, 'createdAt', 'DESC'], // 将使用简单的关联对象按关联模型的 createdAt 排序. [{model: Task, as: 'Task'}, 'createdAt', 'DESC'], // 将由嵌套关联模型的 createdAt 简单关联对象排序. [{model: Task, as: 'Task'}, {model: Project, as: 'Project'}, 'createdAt', 'DESC'] ], // 将按最大年龄降序排列 order: sequelize.literal('max(age) DESC'), // 如果忽略方向,则默认升序,将按最大年龄升序排序 order: sequelize.fn('max', sequelize.col('age')), // 如果省略方向,则默认升序, 将按年龄升序排列 order: sequelize.col('age'), // 将根据方言随机排序(但不是 fn('RAND') 或 fn('RANDOM')) order: sequelize.random() }); Foo.findOne({ order: [ // 将返回 `name` ['name'], // 将返回 `username` DESC ['username', 'DESC'], // 将返回 max(`age`) sequelize.fn('max', sequelize.col('age')), // 将返回 max(`age`) DESC [sequelize.fn('max', sequelize.col('age')), 'DESC'], // 将返回 otherfunction(`col1`, 12, 'lalala') DESC [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'], // 将返回 otherfunction(awesomefunction(`col`)) DESC, 这种嵌套可能是无限的! [sequelize.fn('otherfunction', sequelize.fn('awesomefunction', sequelize.col('col'))), 'DESC'] ] }); 回顾一下,order 数组的元素可以如下： 一个字符串 (它将被自动引用) 一个数组, 其第一个元素将被引用,第二个将被逐字追加 一个具有 raw 字段的对象: raw 内容将不加引用地逐字添加 其他所有内容都将被忽略,如果未设置 raw,查询将失败 调用 Sequelize.fn (这将在 SQL 中生成一个函数调用) 调用 Sequelize.col (这将引用列名) 分组 分组和排序的语法相同,只是分组不接受方向作为数组的最后一个参数(不存在 ASC, DESC, NULLS FIRST 等). 你还可以将字符串直接传递给 group,该字符串将直接(普通)包含在生成的 SQL 中. 请谨慎使用,请勿与用户生成的内容一起使用. Project.findAll({ group: 'name' }); // 生成 'GROUP BY name' 限制和分页 使用 limit 和 offset 参数可以进行 限制/分页： // 提取10个实例/行 Project.findAll({ limit: 10 }); // 跳过8个实例/行 Project.findAll({ offset: 8 }); // 跳过5个实例,然后获取5个实例 Project.findAll({ offset: 5, limit: 5 }); 通常这些与 order 参数一起使用. 实用方法 Sequelize 还提供了一些实用方法. count count 方法仅计算数据库中元素出现的次数. console.log(`这有 ${await Project.count()} 个项目`); const amount = await Project.count({ where: { id: { [Op.gt]: 25 } } }); console.log(`这有 ${amount} 个项目 id 大于 25`); max, min 和 sum Sequelize 还提供了 max,min 和 sum 便捷方法. 假设我们有三个用户,分别是10、5和40岁. await User.max('age'); // 40 await User.max('age', { where: { age: { [Op.lt]: 20 } } }); // 10 await User.min('age'); // 5 await User.min('age', { where: { age: { [Op.gt]: 5 } } }); // 10 await User.sum('age'); // 55 await User.sum('age', { where: { age: { [Op.gt]: 5 } } }); // 50 increment, decrement Sequelize 还提供了 increment 简便方法。 假设我们有一个用户, 他的年龄是 10 岁. await User.increment({age: 5}, { where: { id: 1 } }) // 将年龄增加到15岁 await User.increment({age: -5}, { where: { id: 1 } }) // 将年龄降至5岁 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"core-concepts/model-querying-finders.html":{"url":"core-concepts/model-querying-finders.html","title":"Model Querying - Finders - 模型查询(查找器)","keywords":"","body":"Model Querying - Finders - 模型查询(查找器) Finder 方法是生成 SELECT 查询的方法. 默认情况下,所有 finder 方法的结果都是模型类的实例(与普通的 JavaScript 对象相反). 这意味着在数据库返回结果之后,Sequelize 会自动将所有内容包装在适当的实例对象中. 在少数情况下,当结果太多时,这种包装可能会效率低下. 要禁用此包装并收到简单的响应,请将 { raw: true } 作为参数传递给 finder 方法. findAll 在上一教程中已经知道 findAll 方法. 它生成一个标准的 SELECT 查询,该查询将从表中检索所有条目(除非受到 where 子句的限制). findByPk findByPk 方法使用提供的主键从表中仅获得一个条目. const project = await Project.findByPk(123); if (project === null) { console.log('Not found!'); } else { console.log(project instanceof Project); // true // 它的主键是 123 } findOne findOne 方法获得它找到的第一个条目(它可以满足提供的可选查询参数). const project = await Project.findOne({ where: { title: 'My Title' } }); if (project === null) { console.log('Not found!'); } else { console.log(project instanceof Project); // true console.log(project.title); // 'My Title' } findOrCreate 除非找到一个满足查询参数的结果,否则方法 findOrCreate 将在表中创建一个条目. 在这两种情况下,它将返回一个实例(找到的实例或创建的实例)和一个布尔值,指示该实例是已创建还是已经存在. 使用 where 参数来查找条目,而使用 defaults 参数来定义必须创建的内容. 如果 defaults 不包含每一列的值,则 Sequelize 将采用 where 的值(如果存在). 假设我们有一个空的数据库,该数据库具有一个 User 模型,该模型具有一个 username 和一个 job. const [user, created] = await User.findOrCreate({ where: { username: 'sdepold' }, defaults: { job: 'Technical Lead JavaScript' } }); console.log(user.username); // 'sdepold' console.log(user.job); // 这可能是也可能不是 'Technical Lead JavaScript' console.log(created); // 指示此实例是否刚刚创建的布尔值 if (created) { console.log(user.job); // 这里肯定是 'Technical Lead JavaScript' } findAndCountAll findAndCountAll 方法是结合了 findAll 和 count 的便捷方法. 在处理与分页有关的查询时非常有用,在分页中,你想检索带有 limit 和 offset 的数据,但又需要知道与查询匹配的记录总数. 当没有提供 group 时, findAndCountAll 方法返回一个具有两个属性的对象： count - 一个整数 - 与查询匹配的记录总数 rows - 一个数组对象 - 获得的记录 当提供了 group 时, findAndCountAll 方法返回一个具有两个属性的对象： count - 一个数组对象 - 包含每组中的合计和预设属性 rows - 一个数组对象 - 获得的记录 const { count, rows } = await Project.findAndCountAll({ where: { title: { [Op.like]: 'foo%' } }, offset: 10, limit: 2 }); console.log(count); console.log(rows); 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"core-concepts/getters-setters-virtuals.html":{"url":"core-concepts/getters-setters-virtuals.html","title":"Getters, Setters & Virtuals - 获取器, 设置器 & 虚拟字段","keywords":"","body":"Getters, Setters & Virtuals - 获取器, 设置器 & 虚拟字段 Sequelize 允许你为模型的属性定义自定义获取器和设置器. Sequelize 还允许你指定所谓的 虚拟属性,它们是 Sequelize 模型上的属性,这些属性在基础 SQL 表中实际上并不存在,而是由 Sequelize 自动填充. 它们对于创建自定义属性非常有用, 这也可以简化您的代码. 获取器 获取器是为模型定义中的一列定义的 get() 函数： const User = sequelize.define('user', { // 假设我们想要以大写形式查看每个用户名, // 即使它们在数据库本身中不一定是大写的 username: { type: DataTypes.STRING, get() { const rawValue = this.getDataValue('username'); return rawValue ? rawValue.toUpperCase() : null; } } }); 就像标准 JavaScript 获取器一样,在读取字段值时会自动调用此获取器： const user = User.build({ username: 'SuperUser123' }); console.log(user.username); // 'SUPERUSER123' console.log(user.getDataValue('username')); // 'SuperUser123' 注意,尽管上面记录为 SUPERUSER123,但是真正存储在数据库中的值仍然是 SuperUser123. 我们使用了 this.getDataValue('username') 来获得该值,并将其转换为大写. 如果我们尝试在获取器中使用 this.username,我们将陷入无限循环！ 这就是为什么 Sequelize 提供 getDataValue 方法的原因. 设置器 设置器是为模型定义中的一列定义的 set() 函数. 它接收要设置的值： const User = sequelize.define('user', { username: DataTypes.STRING, password: { type: DataTypes.STRING, set(value) { // 在数据库中以明文形式存储密码是很糟糕的. // 使用适当的哈希函数来加密哈希值更好. this.setDataValue('password', hash(value)); } } }); const user = User.build({ username: 'someone', password: 'NotSo§tr0ngP4$SW0RD!' }); console.log(user.password); // '7cfc84b8ea898bb72462e78b4643cfccd77e9f05678ec2ce78754147ba947acc' console.log(user.getDataValue('password')); // '7cfc84b8ea898bb72462e78b4643cfccd77e9f05678ec2ce78754147ba947acc' Sequelize 在将数据发送到数据库之前自动调用了设置器. 数据库得到的唯一数据是已经散列过的值. 如果我们想将模型实例中的另一个字段包含在计算中,那也是可以的,而且非常容易！ const User = sequelize.define('user', { username: DataTypes.STRING, password: { type: DataTypes.STRING, set(value) { // 在数据库中以明文形式存储密码是很糟糕的. // 使用适当的哈希函数来加密哈希值更好. // 使用用户名作为盐更好. this.setDataValue('password', hash(this.username + value)); } } }); 注意： 上面涉及密码处理的示例尽管比单纯以明文形式存储密码要好得多,但远非完美的安全性. 正确处理密码很困难,这里的所有内容只是为了举例说明 Sequelize 功能. 我们建议让网络安全专家阅读 OWASP 文档或者访问 InfoSec StackExchange. 组合获取器和设置器 获取器和设置器都可以在同一字段中定义. 举个例子,假设我们正在建一个 Post 模型,其 content 是无限长度的文本. 假设要提高内存使用率,我们要存储内容的压缩版本. 注意：在这种情况下,现代数据库应会自动进行一些压缩. 这只是为了举例. const { gzipSync, gunzipSync } = require('zlib'); const Post = sequelize.define('post', { content: { type: DataTypes.TEXT, get() { const storedValue = this.getDataValue('content'); const gzippedBuffer = Buffer.from(storedValue, 'base64'); const unzippedBuffer = gunzipSync(gzippedBuffer); return unzippedBuffer.toString(); }, set(value) { const gzippedBuffer = gzipSync(value); this.setDataValue('content', gzippedBuffer.toString('base64')); } } }); 通过上述设置,每当我们尝试与 Post 模型的 content 字段进行交互时,Sequelize 都会自动处理自定义的获取器和设置器. 例如： const post = await Post.create({ content: 'Hello everyone!' }); console.log(post.content); // 'Hello everyone!' // 一切都在幕后进行,所以我们甚至都可以忘记内容实际上是 // 作为 gzip 压缩的 base64 字符串存储的！ // 但是,如果我们真的很好奇,我们可以获取 'raw' 数据... console.log(post.getDataValue('content')); // Output: 'H4sIAAAAAAAACvNIzcnJV0gtSy2qzM9LVQQAUuk9jQ8AAAA=' 虚拟字段 虚拟字段是 Sequelize 在后台填充的字段,但实际上它们不存在于数据库中. 例如,假设我们有一个 User 的 firstName 和 lastName 属性.\\ 同样,这仅是为了示例. 如果有一种简单的方法能直接获取 全名 那会非常好！ 我们可以将 getters 的概念与 Sequelize 针对这种情况提供的特殊数据类型结合使用：DataTypes.VIRTUAL: const { DataTypes } = require(\"sequelize\"); const User = sequelize.define('user', { firstName: DataTypes.TEXT, lastName: DataTypes.TEXT, fullName: { type: DataTypes.VIRTUAL, get() { return `${this.firstName} ${this.lastName}`; }, set(value) { throw new Error('不要尝试设置 `fullName` 的值!'); } } }); VIRTUAL 字段不会导致数据表也存在此列. 换句话说,上面的模型虽然没有 fullName 列. 但是它似乎存在着！ const user = await User.create({ firstName: 'John', lastName: 'Doe' }); console.log(user.fullName); // 'John Doe' 在 Sequelize v7 中已弃用：getterMethods 和 setterMethods Sequelize 在模型定义中还提供了 getterMethods 和 setterMethods 参数,以指定看起来像但与虚拟属性不完全相同的事物. 不鼓励使用此方法,并且将来可能会不建议使用(建议直接使用虚拟属性). 示例: const { Sequelize, DataTypes } = require('sequelize'); const sequelize = new Sequelize('sqlite::memory:'); const User = sequelize.define('user', { firstName: DataTypes.STRING, lastName: DataTypes.STRING }, { getterMethods: { fullName() { return this.firstName + ' ' + this.lastName; } }, setterMethods: { fullName(value) { // 注意：这仅用于演示. // 查阅: https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/ const names = value.split(' '); const firstName = names[0]; const lastName = names.slice(1).join(' '); this.setDataValue('firstName', firstName); this.setDataValue('lastName', lastName); } } }); (async () => { await sequelize.sync(); let user = await User.create({ firstName: 'John', lastName: 'Doe' }); console.log(user.fullName); // 'John Doe' user.fullName = 'Someone Else'; await user.save(); user = await User.findOne(); console.log(user.firstName); // 'Someone' console.log(user.lastName); // 'Else' })(); 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"core-concepts/validations-and-constraints.html":{"url":"core-concepts/validations-and-constraints.html","title":"Validations & Constraints - 验证 & 约束","keywords":"","body":"Validations & Constraints - 验证 & 约束 在本教程中,你将学习如何在 Sequelize 中设置模型的验证和约束. 对于本教程,将假定以下设置： const { Sequelize, Op, Model, DataTypes } = require(\"sequelize\"); const sequelize = new Sequelize(\"sqlite::memory:\"); const User = sequelize.define(\"user\", { username: { type: DataTypes.TEXT, allowNull: false, unique: true }, hashedPassword: { type: DataTypes.STRING(64), validate: { is: /^[0-9a-f]{64}$/i } } }); (async () => { await sequelize.sync({ force: true }); // 这是代码 })(); 验证和约束的区别 验证是在纯 JavaScript 中在 Sequelize 级别执行的检查. 如果你提供自定义验证器功能,它们可能会非常复杂,也可能是 Sequelize 提供的内置验证器之一. 如果验证失败,则根本不会将 SQL 查询发送到数据库. 另一方面,约束是在 SQL 级别定义的规则. 约束的最基本示例是唯一约束. 如果约束检查失败,则数据库将引发错误,并且 Sequelize 会将错误转发给 JavaScript(在此示例中,抛出 SequelizeUniqueConstraintError). 请注意,在这种情况下,与验证不同,它执行了 SQL 查询. 唯一约束 下面的代码示例在 username 字段上定义了唯一约束： /* ... */ { username: { type: DataTypes.TEXT, allowNull: false, unique: true }, } /* ... */ 同步此模型后(例如,通过调用sequelize.sync),在表中将 username 字段创建为 `username` TEXT UNIQUE,如果尝试插入已存在的用户名将抛出 SequelizeUniqueConstraintError. 允许/禁止 null 值 默认情况下,null 是模型每一列的允许值. 可以通过为列设置 allowNull: false 参数来禁用它,就像在我们的代码示例的 username 字段中所做的一样： /* ... */ { username: { type: DataTypes.TEXT, allowNull: false, unique: true }, } /* ... */ 如果没有 allowNull: false, 那么调用 User.create({}) 将会生效. 关于 allowNull 实现的说明 按照本教程开头所述,allowNull 检查是 Sequelize 中唯一由 验证 和 约束 混合而成的检查. 这是因为： 如果试图将 null 设置到不允许为 null 的字段,则将抛出ValidationError ,而且 不会执行任何 SQL 查询. 另外,在 sequelize.sync 之后,具有 allowNull: false 的列将使用 NOT NULL SQL 约束进行定义. 这样,尝试将值设置为 null 的直接 SQL 查询也将失败. 验证器 使用模型验证器,可以为模型的每个属性指定 格式/内容/继承 验证. 验证会自动在 create, update 和 save 时运行. 你还可以调用 validate() 来手动验证实例. 按属性验证 你可以定义你的自定义验证器,也可以使用由 validator.js (10.11.0) 实现的多个内置验证器,如下所示. sequelize.define('foo', { bar: { type: DataTypes.STRING, validate: { is: /^[a-z]+$/i, // 匹配这个 RegExp is: [\"^[a-z]+$\",'i'], // 与上面相同,但是以字符串构造 RegExp not: /^[a-z]+$/i, // 不匹配 RegExp not: [\"^[a-z]+$\",'i'], // 与上面相同,但是以字符串构造 RegExp isEmail: true, // 检查 email 格式 (foo@bar.com) isUrl: true, // 检查 url 格式 (http://foo.com) isIP: true, // 检查 IPv4 (129.89.23.1) 或 IPv6 格式 isIPv4: true, // 检查 IPv4 格式 (129.89.23.1) isIPv6: true, // 检查 IPv6 格式 isAlpha: true, // 只允许字母 isAlphanumeric: true, // 将仅允许使用字母数字,因此 '_abc' 将失败 isNumeric: true, // 只允许数字 isInt: true, // 检查有效的整数 isFloat: true, // 检查有效的浮点数 isDecimal: true, // 检查任何数字 isLowercase: true, // 检查小写 isUppercase: true, // 检查大写 notNull: true, // 不允许为空 isNull: true, // 只允许为空 notEmpty: true, // 不允许空字符串 equals: 'specific value', // 仅允许 'specific value' contains: 'foo', // 强制特定子字符串 notIn: [['foo', 'bar']], // 检查值不是这些之一 isIn: [['foo', 'bar']], // 检查值是其中之一 notContains: 'bar', // 不允许特定的子字符串 len: [2,10], // 仅允许长度在2到10之间的值 isUUID: 4, // 只允许 uuid isDate: true, // 只允许日期字符串 isAfter: \"2011-11-05\", // 仅允许特定日期之后的日期字符串 isBefore: \"2011-11-05\", // 仅允许特定日期之前的日期字符串 max: 23, // 仅允许值 = 23 isCreditCard: true, // 检查有效的信用卡号 // 自定义验证器的示例: isEven(value) { if (parseInt(value) % 2 !== 0) { throw new Error('Only even values are allowed!'); } } isGreaterThanOtherField(value) { if (parseInt(value) 请注意,在需要将多个参数传递给内置验证函数的情况下,要传递的参数必须位于数组中. 但是,如果要传递单个数组参数,例如,isIn 可接受的字符串数组,则将其解释为多个字符串参数,而不是一个数组参数. 要解决此问题,请传递一个单长度的参数数组,例如上面所示的 [['foo', 'bar']] . 要使用自定义错误消息而不是 validator.js 提供的错误消息,请使用对象而不是纯值或参数数组,例如验证器 不需要参数就可以给自定义消息 isInt: { msg: \"必须是价格的整数\" } 或者如果还需要传递参数,则添加一个 args 属性： isIn: { args: [['en', 'zh']], msg: \"必须为英文或中文\" } 使用自定义验证器功能时,错误消息将是抛出的 Error 对象所持有的任何消息. 有关内置验证方法的更多详细信息,请参见validator.js 项目. 提示: 你还可以为日志记录部分定义自定义功能. 只需传递一个函数. 第一个参数是记录的字符串. allowNull 与其他验证器的交互 如果将模型的特定字段设置为不允许为 null(使用 allowNull: false),并且该值已设置为 null,则将跳过所有验证器,并抛出 ValidationError. 另一方面,如果将其设置为允许 null(使用 allowNull: true),并且该值已设置为 null,则仅会跳过内置验证器,而自定义验证器仍将运行. 举例来说,这意味着你可以拥有一个字符串字段,该字段用于验证其长度在5到10个字符之间,但也允许使用 null (因为当该值为 null 时,长度验证器将被自动跳过)： class User extends Model {} User.init({ username: { type: DataTypes.STRING, allowNull: true, validate: { len: [5, 10] } } }, { sequelize }); 你也可以使用自定义验证器有条件地允许 null 值,因为不会跳过它： class User extends Model {} User.init({ age: Sequelize.INTEGER, name: { type: DataTypes.STRING, allowNull: true, validate: { customValidator(value) { if (value === null && this.age !== 10) { throw new Error(\"除非年龄为10,否则名称不能为 null\"); } }) } } }, { sequelize }); 你可以通过设置 notNull 验证器来自定义 allowNull 错误消息： class User extends Model {} User.init({ name: { type: DataTypes.STRING, allowNull: false, validate: { notNull: { msg: '请输入你的名字' } } } }, { sequelize }); 模型范围内的验证 还可以定义验证,来在特定于字段的验证器之后检查模型. 例如,使用此方法,可以确保既未设置 latitude 和 longitude,又未同时设置两者. 如果设置了一个但未设置另一个,则失败. 使用模型对象的上下文调用模型验证器方法,如果它们抛出错误,则认为失败,否则将通过. 这与自定义字段特定的验证器相同. 所收集的任何错误消息都将与字段验证错误一起放入验证结果对象中,其关键字以 validate 选项对象中验证方法失败的键命名. 即便在任何时候每种模型验证方法都只有一个错误消息,但它会在数组中显示为单个字符串错误,以最大程度地提高与字段错误的一致性. 一个例子: class Place extends Model {} Place.init({ name: Sequelize.STRING, address: Sequelize.STRING, latitude: { type: DataTypes.INTEGER, validate: { min: -90, max: 90 } }, longitude: { type: DataTypes.INTEGER, validate: { min: -180, max: 180 } }, }, { sequelize, validate: { bothCoordsOrNone() { if ((this.latitude === null) !== (this.longitude === null)) { throw new Error('Either both latitude and longitude, or neither!'); } } } }) 在这种简单的情况下,如果只给定了纬度或经度,而不是同时给出两者, 则不能验证对象. 如果我们尝试构建一个超出范围的纬度且没有经度的对象,则somePlace.validate() 可能会返回： { 'latitude': ['Invalid number: latitude'], 'bothCoordsOrNone': ['Either both latitude and longitude, or neither!'] } 也可以使用在单个属性上定义的自定义验证程序(例如 latitude 属性,通过检查 (value === null) !== (this.longitude === null) )来完成此类验证, 但模型范围内的验证方法更为简洁. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"core-concepts/raw-queries.html":{"url":"core-concepts/raw-queries.html","title":"Raw Queries - 原始查询","keywords":"","body":"Raw Queries - 原始查询 由于常常使用简单的方式来执行原始/已经准备好的SQL查询,因此可以使用 sequelize.query 方法. 默认情况下,函数将返回两个参数 - 一个结果数组,以及一个包含元数据(例如受影响的行数等)的对象. 请注意,由于这是一个原始查询,所以元数据都是具体的方言. 某些方言返回元数据 \"within\" 结果对象(作为数组上的属性). 但是,将永远返回两个参数,但对于MSSQL和MySQL,它将是对同一对象的两个引用. const [results, metadata] = await sequelize.query(\"UPDATE users SET y = 42 WHERE x = 12\"); // 结果将是一个空数组,元数据将包含受影响的行数. 在不需要访问元数据的情况下,你可以传递一个查询类型来告诉后续如何格式化结果. 例如,对于一个简单的选择查询你可以做: const { QueryTypes } = require('sequelize'); const users = await sequelize.query(\"SELECT * FROM `users`\", { type: QueryTypes.SELECT }); // 我们不需要在这里分解结果 - 结果会直接返回 还有其他几种查询类型可用. 详细了解来源. 第二种选择是模型. 如果传递模型,返回的数据将是该模型的实例. // Callee 是模型定义. 这样你就可以轻松地将查询映射到预定义的模型 const projects = await sequelize.query('SELECT * FROM projects', { model: Projects, mapToModel: true // 如果你有任何映射字段,则在此处传递 true }); // 现在,`projects` 的每个元素都是 Project 的一个实例 查看 Query API 参考中的更多参数. 以下是一些例子: const { QueryTypes } = require('sequelize'); await sequelize.query('SELECT 1', { // 用于记录查询的函数(或false) // 将调用发送到服务器的每个SQL查询. logging: console.log, // 如果plain为true,则sequelize将仅返回结果集的第一条记录. // 如果是false,它将返回所有记录. plain: false, // 如果你没有查询的模型定义,请将此项设置为true. raw: false, // 你正在执行的查询类型. 查询类型会影响结果在传回之前的格式. type: QueryTypes.SELECT }); // 注意第二个参数为null！ // 即使我们在这里声明了一个被调用对象, // raw: true 也会取代并返回一个原始对象. console.log(await sequelize.query('SELECT * FROM projects', { raw: true })); \"Dotted\" 属性 和 nest 参数 如果表的属性名称包含点,则可以通过设置 nest: true 参数将生成的对象变为嵌套对象. 这可以通过 dottie.js 在后台实现. 见下文： 不使用 nest: true: const { QueryTypes } = require('sequelize'); const records = await sequelize.query('select 1 as `foo.bar.baz`', { type: QueryTypes.SELECT }); console.log(JSON.stringify(records[0], null, 2)); { \"foo.bar.baz\": 1 } 使用 nest: true: const { QueryTypes } = require('sequelize'); const records = await sequelize.query('select 1 as `foo.bar.baz`', { nest: true, type: QueryTypes.SELECT }); console.log(JSON.stringify(records[0], null, 2)); { \"foo\": { \"bar\": { \"baz\": 1 } } } 替换 查询中的替换可以通过两种不同的方式完成:使用命名参数(以:开头),或者由？表示的未命名参数. 替换在options对象中传递. 如果传递一个数组, ? 将按照它们在数组中出现的顺序被替换 如果传递一个对象, :key 将替换为该对象的键. 如果对象包含在查询中找不到的键,则会抛出异常,反之亦然. const { QueryTypes } = require('sequelize'); await sequelize.query( 'SELECT * FROM projects WHERE status = ?', { replacements: ['active'], type: QueryTypes.SELECT } ); await sequelize.query( 'SELECT * FROM projects WHERE status = :status', { replacements: { status: 'active' }, type: QueryTypes.SELECT } ); 数组替换将自动处理,以下查询将搜索状态与值数组匹配的项目. const { QueryTypes } = require('sequelize'); await sequelize.query( 'SELECT * FROM projects WHERE status IN(:status)', { replacements: { status: ['active', 'inactive'] }, type: QueryTypes.SELECT } ); 要使用通配符运算符 ％,请将其附加到你的替换中. 以下查询与名称以 'ben' 开头的用户相匹配. const { QueryTypes } = require('sequelize'); await sequelize.query( 'SELECT * FROM users WHERE name LIKE :search_name', { replacements: { search_name: 'ben%' }, type: QueryTypes.SELECT } ); 绑定参数 绑定参数就像替换. 除非替换被转义并在查询发送到数据库之前通过后续插入到查询中,而将绑定参数发送到SQL查询文本之外的数据库. 查询可以具有绑定参数或替换.绑定参数由 $1, $2, ... (numeric) 或 $key (alpha-numeric) 引用.这是独立于方言的. 如果传递一个数组, $1 被绑定到数组中的第一个元素 (bind[0]). 如果传递一个对象, $key 绑定到 object['key']. 每个键必须以非数字字符开始. $1 不是一个有效的键,即使 object['1'] 存在. 在这两种情况下 $$ 可以用来转义一个 $ 字符符号. 数组或对象必须包含所有绑定的值,或者Sequelize将抛出异常. 这甚至适用于数据库可能忽略绑定参数的情况. 数据库可能会增加进一步的限制. 绑定参数不能是SQL关键字,也不能是表或列名. 引用的文本或数据也忽略它们. 在PostgreSQL中,如果不能从上下文 $1::varchar 推断类型,那么也可能需要对其进行类型转换. const { QueryTypes } = require('sequelize'); await sequelize.query( 'SELECT *, \"text with literal $$1 and literal $$status\" as t FROM projects WHERE status = $1', { bind: ['active'], type: QueryTypes.SELECT } ); await sequelize.query( 'SELECT *, \"text with literal $$1 and literal $$status\" as t FROM projects WHERE status = $status', { bind: { status: 'active' }, type: QueryTypes.SELECT } ); 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"core-concepts/assocs.html":{"url":"core-concepts/assocs.html","title":"Associations - 关联","keywords":"","body":"Associations - 关联 Sequelize 支持标准关联关系: 一对一, 一对多 和 多对多. 为此,Sequelize 提供了 四种 关联类型,并将它们组合起来以创建关联： HasOne 关联类型 BelongsTo 关联类型 HasMany 关联类型 BelongsToMany 关联类型 该指南将讲解如何定义这四种类型的关联,然后讲解如何将它们组合来定义三种标准关联类型(一对一, 一对多 和 多对多). 定义 Sequelize 关联 四种关联类型的定义非常相似. 假设我们有两个模型 A 和 B. 告诉 Sequelize 两者之间的关联仅需要调用一个函数： const A = sequelize.define('A', /* ... */); const B = sequelize.define('B', /* ... */); A.hasOne(B); // A 有一个 B A.belongsTo(B); // A 属于 B A.hasMany(B); // A 有多个 B A.belongsToMany(B, { through: 'C' }); // A 属于多个 B , 通过联结表 C 它们都接受一个对象作为第二个参数(前三个参数是可选的,而对于包含 through 属性的 belongsToMany 是必需的)： They all accept an options object as a second parameter A.hasOne(B, { /* 参数 */ }); A.belongsTo(B, { /* 参数 */ }); A.hasMany(B, { /* 参数 */ }); A.belongsToMany(B, { through: 'C', /* 参数 */ }); 关联的定义顺序是有关系的. 换句话说,对于这四种情况,定义顺序很重要. 在上述所有示例中,A 称为 源 模型,而 B 称为 目标 模型. 此术语很重要. A.hasOne(B) 关联意味着 A 和 B 之间存在一对一的关系,外键在目标模型(B)中定义. A.belongsTo(B)关联意味着 A 和 B 之间存在一对一的关系,外键在源模型中定义(A). A.hasMany(B) 关联意味着 A 和 B 之间存在一对多关系,外键在目标模型(B)中定义. 这三个调用将导致 Sequelize 自动将外键添加到适当的模型中(除非它们已经存在). A.belongsToMany(B, { through: 'C' }) 关联意味着将表 C 用作联结表,在 A 和 B 之间存在多对多关系. 具有外键(例如,aId 和 bId). Sequelize 将自动创建此模型 C(除非已经存在),并在其上定义适当的外键. 注意：在上面的 belongsToMany 示例中,字符串('C')被传递给 through 参数. 在这种情况下,Sequelize 会自动使用该名称生成模型. 但是,如果已经定义了模型,也可以直接传递模型. 这些是每种关联类型中涉及的主要思想. 但是,这些关系通常成对使用,以便 Sequelize 更好地使用. 这将在后文中看到. 创建标准关系 如前所述,Sequelize 关联通常成对定义. 综上所述： 创建一个 一对一 关系, hasOne 和 belongsTo 关联一起使用; 创建一个 一对多 关系, hasMany he belongsTo 关联一起使用; 创建一个 多对多 关系, 两个 belongsToMany 调用一起使用. 注意: 还有一个 超级多对多 关系,一次使用六个关联,将在高级多对多关系指南中进行讨论. 接下来将进行详细介绍. 本章末尾将讨论使用这些成对而不是单个关联的优点. 一对一关系 哲理 在深入探讨使用 Sequelize 的各个方面之前,退后一步来考虑一对一关系会发生什么是很有用的. 假设我们有两个模型,Foo 和 Bar.我们要在 Foo 和 Bar 之间建立一对一的关系.我们知道在关系数据库中,这将通过在其中一个表中建立外键来完成.因此,在这种情况下,一个非常关键的问题是：我们希望该外键在哪个表中？换句话说,我们是要 Foo 拥有 barId 列,还是 Bar 应当拥有 fooId 列？ 原则上,这两个选择都是在 Foo 和 Bar 之间建立一对一关系的有效方法.但是,当我们说 \"Foo 和 Bar 之间存在一对一关系\" 时,尚不清楚该关系是 强制性 的还是可选的.换句话说,Foo 是否可以没有 Bar 而存在？ Foo 的 Bar 可以存在吗？这些问题的答案有助于帮我们弄清楚外键列在哪里. 目标 对于本示例的其余部分,我们假设我们有两个模型,即 Foo 和 Bar. 我们想要在它们之间建立一对一的关系,以便 Bar 获得 fooId 列. 实践 实现该目标的主要设置如下： Foo.hasOne(Bar); Bar.belongsTo(Foo); 由于未传递任何参数,因此 Sequelize 将从模型名称中推断出要做什么. 在这种情况下,Sequelize 知道必须将 fooId 列添加到 Bar 中. 这样,在上述代码之后调用 Bar.sync() 将产生以下 SQL(例如,在PostgreSQL上)： CREATE TABLE IF NOT EXISTS \"foos\" ( /* ... */ ); CREATE TABLE IF NOT EXISTS \"bars\" ( /* ... */ \"fooId\" INTEGER REFERENCES \"foos\" (\"id\") ON DELETE SET NULL ON UPDATE CASCADE /* ... */ ); 参数 可以将各种参数作为关联调用的第二个参数传递. onDelete 和 onUpdate 例如,要配置 ON DELETE 和 ON UPDATE 行为,你可以执行以下操作： Foo.hasOne(Bar, { onDelete: 'RESTRICT', onUpdate: 'RESTRICT' }); Bar.belongsTo(Foo); 可用的参数为 RESTRICT, CASCADE, NO ACTION, SET DEFAULT 和 SET NULL. 一对一关联的默认值, ON DELETE 为 SET NULL 而 ON UPDATE 为 CASCADE. 自定义外键 上面显示的 hasOne 和 belongsTo 调用都会推断出要创建的外键应称为 fooId. 如要使用其他名称,例如 myFooId： // 方法 1 Foo.hasOne(Bar, { foreignKey: 'myFooId' }); Bar.belongsTo(Foo); // 方法 2 Foo.hasOne(Bar, { foreignKey: { name: 'myFooId' } }); Bar.belongsTo(Foo); // 方法 3 Foo.hasOne(Bar); Bar.belongsTo(Foo, { foreignKey: 'myFooId' }); // 方法 4 Foo.hasOne(Bar); Bar.belongsTo(Foo, { foreignKey: { name: 'myFooId' } }); 如上所示,foreignKey 参数接受一个字符串或一个对象. 当接收到一个对象时,该对象将用作列的定义,就像在标准的 sequelize.define 调用中所做的一样. 因此,指定诸如 type, allowNull, defaultValue 等参数就可以了. 例如,要使用 UUID 作为外键数据类型而不是默认值(INTEGER),只需执行以下操作： const { DataTypes } = require(\"Sequelize\"); Foo.hasOne(Bar, { foreignKey: { // name: 'myFooId' type: DataTypes.UUID } }); Bar.belongsTo(Foo); 强制性与可选性关联 默认情况下,该关联被视为可选. 换句话说,在我们的示例中,fooId 允许为空,这意味着一个 Bar 可以不存在 Foo 而存在. 只需在外键选项中指定 allowNull: false 即可更改此设置： Foo.hasOne(Bar, { foreignKey: { allowNull: false } }); // \"fooId\" INTEGER NOT NULL REFERENCES \"foos\" (\"id\") ON DELETE RESTRICT ON UPDATE RESTRICT 一对多关系 原理 一对多关联将一个源与多个目标连接,而所有这些目标仅与此单个源连接. 这意味着,与我们必须选择放置外键的一对一关联不同,在一对多关联中只有一个选项. 例如,如果一个 Foo 有很多 Bar(因此每个 Bar 都属于一个 Foo),那么唯一明智的方式就是在 Bar 表中有一个 fooId 列. 而反过来是不可能的,因为一个 Foo 会有很多 Bar. 目标 在这个例子中,我们有模型 Team 和 Player. 我们要告诉 Sequelize,他们之间存在一对多的关系,这意味着一个 Team 有 Player ,而每个 Player 都属于一个 Team. 实践 这样做的主要方法如下： Team.hasMany(Player); Player.belongsTo(Team); 同样,实现此目标的主要方法是使用一对 Sequelize 关联(hasMany 和 belongsTo). 例如,在 PostgreSQL 中,以上设置将在 sync() 之后产生以下 SQL： CREATE TABLE IF NOT EXISTS \"Teams\" ( /* ... */ ); CREATE TABLE IF NOT EXISTS \"Players\" ( /* ... */ \"TeamId\" INTEGER REFERENCES \"Teams\" (\"id\") ON DELETE SET NULL ON UPDATE CASCADE, /* ... */ ); 参数 在这种情况下要应用的参数与一对一情况相同. 例如,要更改外键的名称并确保该关系是强制性的,我们可以执行以下操作： Team.hasMany(Player, { foreignKey: 'clubId' }); Player.belongsTo(Team); 如同一对一关系, ON DELETE 默认为 SET NULL 而 ON UPDATE 默认为 CASCADE. 多对多关系 原理 多对多关联将一个源与多个目标相连,而所有这些目标又可以与第一个目标之外的其他源相连. 不能像其他关系那样通过向其中一个表添加一个外键来表示这一点. 取而代之的是使用联结模型的概念. 这将是一个额外的模型(以及数据库中的额外表),它将具有两个外键列并跟踪关联. 联结表有时也称为 join table 或 through table. 目标 对于此示例,我们将考虑模型 Movie 和 Actor. 一位 actor 可能参与了许多 movies,而一部 movie 中有许多 actors 参与了其制作. 跟踪关联的联结表将被称为 ActorMovies,其中将包含外键 movieId 和 actorId. 实践 在 Sequelize 中执行此操作的主要方法如下： const Movie = sequelize.define('Movie', { name: DataTypes.STRING }); const Actor = sequelize.define('Actor', { name: DataTypes.STRING }); Movie.belongsToMany(Actor, { through: 'ActorMovies' }); Actor.belongsToMany(Movie, { through: 'ActorMovies' }); 因为在 belongsToMany 的 through 参数中给出了一个字符串,所以 Sequelize 将自动创建 ActorMovies 模型作为联结模型. 例如,在 PostgreSQL 中： CREATE TABLE IF NOT EXISTS \"ActorMovies\" ( \"createdAt\" TIMESTAMP WITH TIME ZONE NOT NULL, \"updatedAt\" TIMESTAMP WITH TIME ZONE NOT NULL, \"MovieId\" INTEGER REFERENCES \"Movies\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE, \"ActorId\" INTEGER REFERENCES \"Actors\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE, PRIMARY KEY (\"MovieId\",\"ActorId\") ); 除了字符串以外,还支持直接传递模型,在这种情况下,给定的模型将用作联结模型(并且不会自动创建任何模型). 例如： const Movie = sequelize.define('Movie', { name: DataTypes.STRING }); const Actor = sequelize.define('Actor', { name: DataTypes.STRING }); const ActorMovies = sequelize.define('ActorMovies', { MovieId: { type: DataTypes.INTEGER, references: { model: Movie, // 'Movies' 也可以使用 key: 'id' } }, ActorId: { type: DataTypes.INTEGER, references: { model: Actor, // 'Actors' 也可以使用 key: 'id' } } }); Movie.belongsToMany(Actor, { through: ActorMovies }); Actor.belongsToMany(Movie, { through: ActorMovies }); 上面的代码在 PostgreSQL 中产生了以下 SQL,与上面所示的代码等效： CREATE TABLE IF NOT EXISTS \"ActorMovies\" ( \"MovieId\" INTEGER NOT NULL REFERENCES \"Movies\" (\"id\") ON DELETE RESTRICT ON UPDATE CASCADE, \"ActorId\" INTEGER NOT NULL REFERENCES \"Actors\" (\"id\") ON DELETE RESTRICT ON UPDATE CASCADE, \"createdAt\" TIMESTAMP WITH TIME ZONE NOT NULL, \"updatedAt\" TIMESTAMP WITH TIME ZONE NOT NULL, UNIQUE (\"MovieId\", \"ActorId\"), -- 注意: Sequelize 产生了这个 UNIQUE 约束,但是 PRIMARY KEY (\"MovieId\",\"ActorId\") -- 这没有关系,因为它也是 PRIMARY KEY ); 参数 与一对一和一对多关系不同,对于多对多关系,ON UPDATE 和 ON DELETE 的默认值为 CASCADE. 当模型中不存在主键时，Belongs-to-Many 将创建一个唯一键. 可以使用 uniqueKey 参数覆盖此唯一键名. 若不希望产生唯一键, 可以使用 unique: false 参数. Project.belongsToMany(User, { through: UserProjects, uniqueKey: 'my_custom_unique' }) 基本的涉及关联的查询 了解了定义关联的基础知识之后,我们可以查看涉及关联的查询. 最常见查询是 read 查询(即 SELECT). 稍后,将展示其他类型的查询. 为了研究这一点,我们将思考一个例子,其中有船和船长,以及它们之间的一对一关系. 我们将在外键上允许 null(默认值),这意味着船可以在没有船长的情况下存在,反之亦然. // 这是我们用于以下示例的模型的设置 const Ship = sequelize.define('ship', { name: DataTypes.STRING, crewCapacity: DataTypes.INTEGER, amountOfSails: DataTypes.INTEGER }, { timestamps: false }); const Captain = sequelize.define('captain', { name: DataTypes.STRING, skillLevel: { type: DataTypes.INTEGER, validate: { min: 1, max: 10 } } }, { timestamps: false }); Captain.hasOne(Ship); Ship.belongsTo(Captain); 获取关联 - 预先加载 vs 延迟加载 预先加载和延迟加载的概念是理解获取关联如何在 Sequelize 中工作的基础. 延迟加载是指仅在确实需要时才获取关联数据的技术. 另一方面,预先加载是指从一开始就通过较大的查询一次获取所有内容的技术. 延迟加载示例 const awesomeCaptain = await Captain.findOne({ where: { name: \"Jack Sparrow\" } }); // 用获取到的 captain 做点什么 console.log('Name:', awesomeCaptain.name); console.log('Skill Level:', awesomeCaptain.skillLevel); // 现在我们需要有关他的 ship 的信息! const hisShip = await awesomeCaptain.getShip(); // 用 ship 做点什么 console.log('Ship Name:', hisShip.name); console.log('Amount of Sails:', hisShip.amountOfSails); 请注意,在上面的示例中,我们进行了两个查询,仅在要使用它时才获取关联的 ship. 如果我们可能需要也可能不需要这艘 ship,或者我们只想在少数情况下有条件地取回它,这会特别有用; 这样,我们可以仅在必要时提取,从而节省时间和内存. 注意：上面使用的 getShip() 实例方法是 Sequelize 自动添加到 Captain 实例的方法之一. 还有其他方法, 你将在本指南的后面部分进一步了解它们. 预先加载示例 const awesomeCaptain = await Captain.findOne({ where: { name: \"Jack Sparrow\" }, include: Ship }); // 现在 ship 跟着一起来了 console.log('Name:', awesomeCaptain.name); console.log('Skill Level:', awesomeCaptain.skillLevel); console.log('Ship Name:', awesomeCaptain.ship.name); console.log('Amount of Sails:', awesomeCaptain.ship.amountOfSails); 如上所示,通过使用 include 参数 在 Sequelize 中执行预先加载. 观察到这里只对数据库执行了一个查询(与实例一起带回关联的数据). 这只是 Sequelize 中预先加载的简单介绍. 还有更多内容,你可以在预先加载的专用指南中学习 创建, 更新和删除 上面显示了查询有关关联的数据的基础知识. 对于创建,更新和删除,你可以： 直接使用标准模型查询： // 示例：使用标准方法创建关联的模型 Bar.create({ name: 'My Bar', fooId: 5 }); // 这将创建一个属于 ID 5 的 Foo 的 Bar // 这里没有什么特别的东西 或使用关联模型可用的 特殊方法/混合 ,这将在本文稍后进行解释. 注意: save()实例方法 并不知道关联关系. 如果你修改了 父级 对象预先加载的 子级 的值,那么在父级上调用 save() 将会忽略子级上发生的修改. 关联别名 & 自定义外键 在以上所有示例中,Sequelize 自动定义了外键名称. 例如,在船和船长示例中,Sequelize 在 Ship 模型上自动定义了一个 captainId 字段. 然而,想要自定义外键也是很容易的. 让我们以简化的形式考虑 Ship 和 Captain 模型,仅着眼于当前主题,如下所示(较少的字段)： const Ship = sequelize.define('ship', { name: DataTypes.STRING }, { timestamps: false }); const Captain = sequelize.define('captain', { name: DataTypes.STRING }, { timestamps: false }); 有三种方法可以为外键指定不同的名称： 通过直接提供外键名称 通过定义别名 通过两个方法同时进行 回顾: 默认设置 通过简单地使用 Ship.belongsTo(Captain),sequelize 将自动生成外键名称： Ship.belongsTo(Captain); // 这将在 Ship 中创建 `captainId` 外键. // 通过将模型传递给 `include` 来完成预先加载: console.log((await Ship.findAll({ include: Captain })).toJSON()); // 或通过提供关联的模型名称: console.log((await Ship.findAll({ include: 'captain' })).toJSON()); // 同样,实例获得用于延迟加载的 `getCaptain()` 方法： const ship = Ship.findOne(); console.log((await ship.getCaptain()).toJSON()); 直接提供外键名称 可以直接在关联定义的参数中提供外键名称,如下所示： Ship.belongsTo(Captain, { foreignKey: 'bossId' }); // 这将在 Ship 中创建 `bossId` 外键. // 通过将模型传递给 `include` 来完成预先加载: console.log((await Ship.findAll({ include: Captain })).toJSON()); // 或通过提供关联的模型名称: console.log((await Ship.findAll({ include: 'Captain' })).toJSON()); // 同样,实例获得用于延迟加载的 `getCaptain()` 方法: const ship = Ship.findOne(); console.log((await ship.getCaptain()).toJSON()); 定义别名 定义别名比简单指定外键的自定义名称更强大. 通过一个示例可以更好地理解这一点： Ship.belongsTo(Captain, { as: 'leader' }); // 这将在 Ship 中创建 `leaderId` 外键. // 通过将模型传递给 `include` 不能再触发预先加载: console.log((await Ship.findAll({ include: Captain })).toJSON()); // 引发错误 // 相反,你必须传递别名: console.log((await Ship.findAll({ include: 'leader' })).toJSON()); // 或者,你可以传递一个指定模型和别名的对象: console.log((await Ship.findAll({ include: { model: Captain, as: 'leader' } })).toJSON()); // 同样,实例获得用于延迟加载的 `getLeader()`方法: const ship = Ship.findOne(); console.log((await ship.getLeader()).toJSON()); 当你需要在同一模型之间定义两个不同的关联时,别名特别有用. 例如,如果我们有Mail 和 Person 模型,则可能需要将它们关联两次,以表示邮件的 sender 和 receiver. 在这种情况下,我们必须为每个关联使用别名,因为否则,诸如 mail.getPerson() 之类的调用将是模棱两可的. 使用 sender 和 receiver 别名,我们将有两种可用的可用方法：mail.getSender() 和 mail.getReceiver(),它们都返回一个Promise. 在为 hasOne 或 belongsTo 关联定义别名时,应使用单词的单数形式(例如上例中的 leader). 另一方面,在为 hasMany 和 belongsToMany 定义别名时,应使用复数形式. 高级多对多关联指南中介绍了定义多对多关系(带有belongsToMany)的别名. 两者都做 我们可以定义别名,也可以直接定义外键: Ship.belongsTo(Captain, { as: 'leader', foreignKey: 'bossId' }); // 这将在 Ship 中创建 `bossId` 外键. // 由于定义了别名,因此仅通过将模型传递给 `include`,预先加载将不起作用: console.log((await Ship.findAll({ include: Captain })).toJSON()); // 引发错误 // 相反,你必须传递别名: console.log((await Ship.findAll({ include: 'leader' })).toJSON()); // 或者,你可以传递一个指定模型和别名的对象: console.log((await Ship.findAll({ include: { model: Captain, as: 'leader' } })).toJSON()); // 同样,实例获得用于延迟加载的 `getLeader()` 方法: const ship = Ship.findOne(); console.log((await ship.getLeader()).toJSON()); 添加到实例的特殊方法 当两个模型之间定义了关联时,这些模型的实例将获得特殊的方法来与其关联的另一方进行交互. 例如,如果我们有两个模型 Foo 和 Bar,并且它们是关联的,则它们的实例将具有以下可用的方法,具体取决于关联类型： Foo.hasOne(Bar) fooInstance.getBar() fooInstance.setBar() fooInstance.createBar() 示例: const foo = await Foo.create({ name: 'the-foo' }); const bar1 = await Bar.create({ name: 'some-bar' }); const bar2 = await Bar.create({ name: 'another-bar' }); console.log(await foo.getBar()); // null await foo.setBar(bar1); console.log((await foo.getBar()).name); // 'some-bar' await foo.createBar({ name: 'yet-another-bar' }); const newlyAssociatedBar = await foo.getBar(); console.log(newlyAssociatedBar.name); // 'yet-another-bar' await foo.setBar(null); // Un-associate console.log(await foo.getBar()); // null Foo.belongsTo(Bar) 来自 Foo.hasOne(Bar) 的相同内容: fooInstance.getBar() fooInstance.setBar() fooInstance.createBar() Foo.hasMany(Bar) fooInstance.getBars() fooInstance.countBars() fooInstance.hasBar() fooInstance.hasBars() fooInstance.setBars() fooInstance.addBar() fooInstance.addBars() fooInstance.removeBar() fooInstance.removeBars() fooInstance.createBar() 示例: const foo = await Foo.create({ name: 'the-foo' }); const bar1 = await Bar.create({ name: 'some-bar' }); const bar2 = await Bar.create({ name: 'another-bar' }); console.log(await foo.getBars()); // [] console.log(await foo.countBars()); // 0 console.log(await foo.hasBar(bar1)); // false await foo.addBars([bar1, bar2]); console.log(await foo.countBars()); // 2 await foo.addBar(bar1); console.log(await foo.countBars()); // 2 console.log(await foo.hasBar(bar1)); // true await foo.removeBar(bar2); console.log(await foo.countBars()); // 1 await foo.createBar({ name: 'yet-another-bar' }); console.log(await foo.countBars()); // 2 await foo.setBars([]); // 取消关联所有先前关联的 Bars console.log(await foo.countBars()); // 0 getter 方法接受参数,就像通常的 finder 方法(例如findAll)一样： const easyTasks = await project.getTasks({ where: { difficulty: { [Op.lte]: 5 } } }); const taskTitles = (await project.getTasks({ attributes: ['title'], raw: true })).map(task => task.title); Foo.belongsToMany(Bar, { through: Baz }) 来自 Foo.hasMany(Bar) 的相同内容: fooInstance.getBars() fooInstance.countBars() fooInstance.hasBar() fooInstance.hasBars() fooInstance.setBars() fooInstance.addBar() fooInstance.addBars() fooInstance.removeBar() fooInstance.removeBars() fooInstance.createBar() 对于 belongsToMany 关系, 默认情况下, getBars() 将返回连接表中的所有字段. 请注意, 任何 include 参数都将应用于目标 Bar 对象, 因此无法像使用 find 方法进行预加载时那样尝试为连接表设置参数. 要选择要包含的连接表的哪些属性, getBars() 支持一个 joinTableAttributes 选项, 其使用类似于在 include 中设置 through.attributes. 例如, 设定 Foo belongsToMany Bar, 以下都将输出没有连接表字段的结果: const foo = Foo.findByPk(id, { include: [{ model: Bar, through: { attributes: [] } }] }) console.log(foo.bars) const foo = Foo.findByPk(id) console.log(foo.getBars({ joinTableAttributes: [] })) 注意: 方法名称 如上面的示例所示,Sequelize 赋予这些特殊方法的名称是由前缀(例如,get,add,set)和模型名称(首字母大写)组成的. 必要时,可以使用复数形式,例如在 fooInstance.setBars() 中. 同样,不规则复数也由 Sequelize 自动处理. 例如,Person 变成 People 或者 Hypothesis 变成 Hypotheses. 如果定义了别名,则将使用别名代替模型名称来形成方法名称. 例如： Task.hasOne(User, { as: 'Author' }); taskInstance.getAuthor() taskInstance.setAuthor() taskInstance.createAuthor() 为什么关联是成对定义的？ 如前所述,就像上面大多数示例中展示的,Sequelize 中的关联通常成对定义： 创建一个 一对一 关系, hasOne 和 belongsTo 关联一起使用; 创建一个 一对多 关系, hasMany he belongsTo 关联一起使用; 创建一个 多对多 关系, 两个 belongsToMany 调用一起使用. 当在两个模型之间定义了 Sequelize 关联时,只有 源 模型 知晓关系. 因此,例如,当使用 Foo.hasOne(Bar)(当前,Foo 是源模型,而 Bar 是目标模型)时,只有 Foo 知道该关联的存在. 这就是为什么在这种情况下,如上所示,Foo 实例获得方法 getBar(), setBar() 和 createBar() 而另一方面,Bar 实例却没有获得任何方法. 类似地,对于 Foo.hasOne(Bar),由于 Foo 了解这种关系,我们可以像 Foo.findOne({ include: Bar }) 中那样执行预先加载,但不能执行 Bar.findOne({ include: Foo }). 因此,为了充分发挥 Sequelize 的作用,我们通常成对设置关系,以便两个模型都 互相知晓. 实际示范: 如果我们未定义关联对,则仅调用 Foo.hasOne(Bar): // 这有效... await Foo.findOne({ include: Bar }); // 但这会引发错误: await Bar.findOne({ include: Foo }); // SequelizeEagerLoadingError: foo is not associated to bar! 如果我们按照建议定义关联对, 即, Foo.hasOne(Bar) 和 Bar.belongsTo(Foo): // 这有效 await Foo.findOne({ include: Bar }); // 这也有效! await Bar.findOne({ include: Foo }); 涉及相同模型的多个关联 在 Sequelize 中,可以在同一模型之间定义多个关联. 你只需要为它们定义不同的别名： Team.hasOne(Game, { as: 'HomeTeam', foreignKey: 'homeTeamId' }); Team.hasOne(Game, { as: 'AwayTeam', foreignKey: 'awayTeamId' }); Game.belongsTo(Team); 创建引用非主键字段的关联 在以上所有示例中,通过引用所涉及模型的主键(在我们的示例中为它们的ID)定义了关联. 但是,Sequelize 允许你定义一个关联,该关联使用另一个字段而不是主键字段来建立关联. 此其他字段必须对此具有唯一的约束(否则,这将没有意义). 对于 belongsTo 关系 首先,回想一下 A.belongsTo(B) 关联将外键放在 源模型 中(即,在 A 中). 让我们再次使用\"船和船长\"的示例. 此外,我们将假定船长姓名是唯一的： const Ship = sequelize.define('ship', { name: DataTypes.STRING }, { timestamps: false }); const Captain = sequelize.define('captain', { name: { type: DataTypes.STRING, unique: true } }, { timestamps: false }); 这样,我们不用在 Ship 上保留 captainId,而是可以保留 captainName 并将其用作关联跟踪器. 换句话说,我们的关系将引用目标模型上的另一列：name 列,而不是从目标模型(Captain)中引用 id. 为了说明这一点,我们必须定义一个 目标键. 我们还必须为外键本身指定一个名称： Ship.belongsTo(Captain, { targetKey: 'name', foreignKey: 'captainName' }); // 这将在源模型(Ship)中创建一个名为 `captainName` 的外键, // 该外键引用目标模型(Captain)中的 `name` 字段. 现在我们可以做类似的事情: await Captain.create({ name: \"Jack Sparrow\" }); const ship = await Ship.create({ name: \"Black Pearl\", captainName: \"Jack Sparrow\" }); console.log((await ship.getCaptain()).name); // \"Jack Sparrow\" 对于 hasOne 和 hasMany 关系 可以将完全相同的想法应用于 hasOne 和 hasMany 关联,但是在定义关联时,我们提供了 sourceKey,而不是提供 targetKey. 这是因为与 belongsTo 不同,hasOne 和 hasMany关联将外键保留在目标模型上： const Foo = sequelize.define('foo', { name: { type: DataTypes.STRING, unique: true } }, { timestamps: false }); const Bar = sequelize.define('bar', { title: { type: DataTypes.STRING, unique: true } }, { timestamps: false }); const Baz = sequelize.define('baz', { summary: DataTypes.STRING }, { timestamps: false }); Foo.hasOne(Bar, { sourceKey: 'name', foreignKey: 'fooName' }); Bar.hasMany(Baz, { sourceKey: 'title', foreignKey: 'barTitle' }); // [...] await Bar.setFoo(\"Foo's Name Here\"); await Baz.addBar(\"Bar's Title Here\"); 对于 belongsToMany 关系 同样的想法也可以应用于 belongsToMany 关系. 但是,与其他情况下(其中只涉及一个外键)不同,belongsToMany 关系涉及两个外键,这些外键保留在额外的表(联结表)上. 请考虑以下设置： const Foo = sequelize.define('foo', { name: { type: DataTypes.STRING, unique: true } }, { timestamps: false }); const Bar = sequelize.define('bar', { title: { type: DataTypes.STRING, unique: true } }, { timestamps: false }); 有四种情况需要考虑： 我们可能希望使用默认的主键为 Foo 和 Bar 进行多对多关系： Foo.belongsToMany(Bar, { through: 'foo_bar' }); // 这将创建具有字段 `fooId` 和 `barID` 的联结表 `foo_bar`. 我们可能希望使用默认主键 Foo 的多对多关系,但使用 Bar 的不同字段： Foo.belongsToMany(Bar, { through: 'foo_bar', targetKey: 'title' }); // 这将创建具有字段 `fooId` 和 `barTitle` 的联结表 `foo_bar`. 我们可能希望使用 Foo 的不同字段和 Bar 的默认主键进行多对多关系： Foo.belongsToMany(Bar, { through: 'foo_bar', sourceKey: 'name' }); // 这将创建具有字段 `fooName` 和 `barId` 的联结表 `foo_bar`. 我们可能希望使用不同的字段为 Foo 和 Bar 使用多对多关系： Foo.belongsToMany(Bar, { through: 'foo_bar', sourceKey: 'name', targetKey: 'title' }); // 这将创建带有字段 `fooName` 和 `barTitle` 的联结表 `foo_bar`. 注意 不要忘记关联中引用的字段必须具有唯一性约束. 否则,将引发错误(对于 SQLite 有时还会发出诡异的错误消息,例如 SequelizeDatabaseError: SQLITE_ERROR: foreign key mismatch - \"ships\" referencing \"captains\"). 在 sourceKey 和 targetKey 之间做出决定的技巧只是记住每个关系在何处放置其外键. 如本指南开头所述： A.belongsTo(B) 将外键保留在源模型中(A),因此引用的键在目标模型中,因此使用了 targetKey. A.hasOne(B) 和 A.hasMany(B) 将外键保留在目标模型(B)中,因此引用的键在源模型中,因此使用了 sourceKey. A.belongsToMany(B) 包含一个额外的表(联结表),因此 sourceKey 和 targetKey 均可用,其中 sourceKey 对应于A(源)中的某个字段而 targetKey 对应于 B(目标)中的某个字段. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"core-concepts/paranoid.html":{"url":"core-concepts/paranoid.html","title":"Paranoid - 偏执表","keywords":"","body":"Paranoid - 偏执表 Sequelize 支持 paranoid 表的概念. 一个 paranoid 表是一个被告知删除记录时不会真正删除它的表.反而一个名为 deletedAt 的特殊列会将其值设置为该删除请求的时间戳. 这意味着偏执表会执行记录的 软删除,而不是 硬删除. 将模型定义为 paranoid 要定义 paranoid 模型,必须将 paranoid: true 参数传递给模型定义. Paranoid 需要时间戳才能起作用(即,如果你传递 timestamps: false 了,paranoid 将不起作用). 你还可以将默认的列名(默认是 deletedAt)更改为其他名称. class Post extends Model {} Post.init({ /* 这是属性 */ }, { sequelize, paranoid: true, // 如果要为 deletedAt 列指定自定义名称 deletedAt: 'destroyTime' }); 删除 当你调用 destroy 方法时,将发生软删除： await Post.destroy({ where: { id: 1 } }); // UPDATE \"posts\" SET \"deletedAt\"=[timestamp] WHERE \"deletedAt\" IS NULL AND \"id\" = 1 如果你确实想要硬删除,并且模型是 paranoid,则可以使用 force: true 参数强制执行： await Post.destroy({ where: { id: 1 }, force: true }); // DELETE FROM \"posts\" WHERE \"id\" = 1 上面的示例以静态的 destroy 方法为例(Post.destroy),所有实例方法的工作方式相同： const post = await Post.create({ title: 'test' }); console.log(post instanceof Post); // true await post.destroy(); // 只设置 `deletedAt` 标志 await post.destroy({ force: true }); // 真的会删除记录 恢复 要恢复软删除的记录,可以使用 restore 方法,该方法在静态版本和实例版本中都提供： // 展示实例 `restore` 方法的示例 // 我们创建一个帖子,对其进行软删除,然后将其还原 const post = await Post.create({ title: 'test' }); console.log(post instanceof Post); // true await post.destroy(); console.log('soft-deleted!'); await post.restore(); console.log('restored!'); // 展示静态 `restore` 方法的示例. // 恢复每个 likes 大于 100 的软删除的帖子 await Post.restore({ where: { likes: { [Op.gt]: 100 } } }); 其他查询行为 Sequelize 执行的每个查询将自动忽略软删除的记录(当然,原始查询除外). 这意味着,例如,findAll 方法将看不到软删除的记录,仅获取未删除的记录. 即使你单纯的调用提供了软删除记录主键的findByPk,结果也将是 null,就好像该记录不存在一样. 如果你真的想让查询看到被软删除的记录,可以将 paranoid: false 参数传递给查询方法. 例如： await Post.findByPk(123); // 如果 ID 123 的记录被软删除,则将返回 `null` await Post.findByPk(123, { paranoid: false }); // 这将检索记录 await Post.findAll({ where: { foo: 'bar' } }); // 这将不会检索软删除的记录 await Post.findAll({ where: { foo: 'bar' }, paranoid: false }); // 这还将检索软删除的记录 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"advanced-association-concepts/eager-loading.html":{"url":"advanced-association-concepts/eager-loading.html","title":"Eager Loading - 预先加载","keywords":"","body":"Eager Loading - 预先加载 如关联指南中简要提到的,预先加载是一次查询多个模型(一个\"主\"模型和一个或多个关联模型)的数据的行为. 在 SQL 级别上,这是具有一个或多个 join) 的查询. 完成此操作后,Sequelize 将在返回的对象中将适当关联的模型添加到适当命名的自动创建的字段中. 在 Sequelize 中,主要通过在模型查找器查询中使用 include 参数(例如,findOne, findAll 等)来完成预先加载. 基本示例 让我们假设以下设置： const User = sequelize.define('user', { name: DataTypes.STRING }, { timestamps: false }); const Task = sequelize.define('task', { name: DataTypes.STRING }, { timestamps: false }); const Tool = sequelize.define('tool', { name: DataTypes.STRING, size: DataTypes.STRING }, { timestamps: false }); User.hasMany(Task); Task.belongsTo(User); User.hasMany(Tool, { as: 'Instruments' }); 获取单个关联元素 首先,让我们用其关联的用户加载所有任务： const tasks = await Task.findAll({ include: User }); console.log(JSON.stringify(tasks, null, 2)); 输出: [{ \"name\": \"A Task\", \"id\": 1, \"userId\": 1, \"user\": { \"name\": \"John Doe\", \"id\": 1 } }] 这里,tasks[0].user instanceof User 是 true. 这表明,当 Sequelize 提取关联的模型时,它们将作为模型实例添加到输出对象. 上面,在获取的任务中,关联的模型被添加到名为 user 的新字段中. Sequelize 会根据关联模型的名称自动选择此字段的名称,在适用的情况下(即关联为 hasMany 或 belongsToMany)使用该字段的复数形式. 换句话说,由于Task.belongsTo(User)导致一项任务与一个用户相关联,因此逻辑选择是单数形式(Sequelize 自动遵循该形式). 获取所有关联的元素 现在,我们将执行相反的操作,而不是加载与给定任务关联的用户,我们将找到与给定用户关联的所有任务. 方法调用本质上是相同的. 唯一的区别是,现在在查询结果中创建的额外字段使用复数形式(在这种情况下为 tasks),其值是任务实例的数组(而不是上面的单个实例). const users = await User.findAll({ include: Task }); console.log(JSON.stringify(users, null, 2)); 输出: [{ \"name\": \"John Doe\", \"id\": 1, \"tasks\": [{ \"name\": \"A Task\", \"id\": 1, \"userId\": 1 }] }] 注意,由于关联是一对多的,因此访问器(结果实例中的tasks属性)是复数的. 获取别名关联 如果关联是别名的(使用as参数),则在包含模型时必须指定此别名. 与其直接将模型传递给 include 参数,不如为对象提供两个选项：model 和 as. 注意上面的用户的 Tool 是如何被别名为 Instruments 的. 为了实现这一点,你必须指定要加载的模型以及别名： const users = await User.findAll({ include: { model: Tool, as: 'Instruments' } }); console.log(JSON.stringify(users, null, 2)); Output: [{ \"name\": \"John Doe\", \"id\": 1, \"Instruments\": [{ \"name\": \"Scissor\", \"id\": 1, \"userId\": 1 }] }] 你也可以包括指定的关联别名相匹配的字符串： User.findAll({ include: 'Instruments' }); // 也可以正常使用 User.findAll({ include: { association: 'Instruments' } }); // 也可以正常使用 需要预先加载 预先加载时,我们可以强制查询仅返回具有关联模型的记录,从而有效地将查询从默认的 OUTER JOIN 转为 INNER JOIN. 这是通过 required: true 参数完成的,如下所示： User.findAll({ include: { model: Task, required: true } }); 此参数也适用于嵌套包含. 在模型级别的预先加载过滤 预先加载时,我们还可以使用 where 参数过滤关联的模型,如以下示例所示： User.findAll({ include: { model: Tool, as: 'Instruments' where: { size: { [Op.ne]: 'small' } } } }); 生成 SQL: SELECT `user`.`id`, `user`.`name`, `Instruments`.`id` AS `Instruments.id`, `Instruments`.`name` AS `Instruments.name`, `Instruments`.`size` AS `Instruments.size`, `Instruments`.`userId` AS `Instruments.userId` FROM `users` AS `user` INNER JOIN `tools` AS `Instruments` ON `user`.`id` = `Instruments`.`userId` AND `Instruments`.`size` != 'small'; 请注意,上面生成的 SQL 查询将仅获取具有至少一个符合条件(在这种情况下为 small)的工具的用户. 出现这种情况是因为,当在 include 内使用 where 参数时,Sequelize 会自动将 required 参数设置为 true. 这意味着,将执行 INNER JOIN 而不是 OUTER JOIN,仅返回具有至少一个匹配子代的父代模型. 还要注意,使用的 where 参数已转换为 INNER JOIN 的 ON 子句的条件. 为了获得 顶层 的 WHERE 子句,而不是 ON 子句,必须做一些不同的事情.接下来将展示. 参考其他列 如果你想在包含模型中应用 WHERE 子句来引用关联模型中的值,则可以简单地使用 Sequelize.col 函数,如以下示例所示： // 查找所有具有至少一项任务的项目,其中 task.state === project.state Project.findAll({ include: { model: Task, where: { state: Sequelize.col('project.state') } } }) 顶层的复杂 where 子句 为了获得涉及嵌套列的顶级 WHERE 子句,Sequelize 提供了一种引用嵌套列的方法：'$nested.column$' 语法. 例如,它可以用于将 where 条件从包含的模型从 ON 条件移动到顶层的 WHERE 子句. User.findAll({ where: { '$Instruments.size$': { [Op.ne]: 'small' } }, include: [{ model: Tool, as: 'Instruments' }] }); 生成 SQL: SELECT `user`.`id`, `user`.`name`, `Instruments`.`id` AS `Instruments.id`, `Instruments`.`name` AS `Instruments.name`, `Instruments`.`size` AS `Instruments.size`, `Instruments`.`userId` AS `Instruments.userId` FROM `users` AS `user` LEFT OUTER JOIN `tools` AS `Instruments` ON `user`.`id` = `Instruments`.`userId` WHERE `Instruments`.`size` != 'small'; $nested.column$ 语法也适用于嵌套了多个级别的列,例如 $some.super.deeply.nested.column$. 因此,你可以使用它对深层嵌套的列进行复杂的过滤. 为了更好地理解内部的 where 参数(在 include 内部使用)和使用与不使用 required 参数与使用 $nested.column$ 语法的顶级 where 之间的所有区别. ,下面我们为你提供四个示例： // Inner where, 默认使用 `required: true` await User.findAll({ include: { model: Tool, as: 'Instruments', where: { size: { [Op.ne]: 'small' } } } }); // Inner where, `required: false` await User.findAll({ include: { model: Tool, as: 'Instruments', where: { size: { [Op.ne]: 'small' } }, required: false } }); // 顶级 where, 默认使用 `required: false` await User.findAll({ where: { '$Instruments.size$': { [Op.ne]: 'small' } }, include: { model: Tool, as: 'Instruments' } }); // 顶级 where, `required: true` await User.findAll({ where: { '$Instruments.size$': { [Op.ne]: 'small' } }, include: { model: Tool, as: 'Instruments', required: true } }); 生成 SQL: -- Inner where, 默认使用 `required: true` SELECT [...] FROM `users` AS `user` INNER JOIN `tools` AS `Instruments` ON `user`.`id` = `Instruments`.`userId` AND `Instruments`.`size` != 'small'; -- Inner where, `required: false` SELECT [...] FROM `users` AS `user` LEFT OUTER JOIN `tools` AS `Instruments` ON `user`.`id` = `Instruments`.`userId` AND `Instruments`.`size` != 'small'; -- 顶级 where, 默认使用 `required: false` SELECT [...] FROM `users` AS `user` LEFT OUTER JOIN `tools` AS `Instruments` ON `user`.`id` = `Instruments`.`userId` WHERE `Instruments`.`size` != 'small'; -- 顶级 where, `required: true` SELECT [...] FROM `users` AS `user` INNER JOIN `tools` AS `Instruments` ON `user`.`id` = `Instruments`.`userId` WHERE `Instruments`.`size` != 'small'; 使用 RIGHT OUTER JOIN 获取 (仅限 MySQL, MariaDB, PostgreSQL 和 MSSQL) 默认情况下,关联是使用 LEFT OUTER JOIN 加载的 - 也就是说,它仅包含来自父表的记录. 如果你使用的方言支持,你可以通过传递 right 选项来将此行为更改为 RIGHT OUTER JOIN. 当前, SQLite 不支持 right joins. 注意: 仅当 required 为 false 时才遵循 right. User.findAll({ include: [{ model: Task // 将创建一个 left join }] }); User.findAll({ include: [{ model: Task, right: true // 将创建一个 right join }] }); User.findAll({ include: [{ model: Task, required: true, right: true // 没有效果, 将创建一个 inner join }] }); User.findAll({ include: [{ model: Task, where: { name: { [Op.ne]: 'empty trash' } }, right: true // 没有效果, 将创建一个 inner join }] }); User.findAll({ include: [{ model: Tool, where: { name: { [Op.ne]: 'empty trash' } }, required: false // 将创建一个 left join }] }); User.findAll({ include: [{ model: Tool, where: { name: { [Op.ne]: 'empty trash' } }, required: false right: true // 将创建一个 right join }] }); 多次预先加载 include 参数可以接收一个数组,以便一次获取多个关联的模型： Foo.findAll({ include: [ { model: Bar, required: true }, { model: Baz, where: /* ... */ }, Qux // { model: Qux } 的简写语法在这里也适用 ] }) 多对多关系的预先加载 当你对具有 \"多对多\" 关系的模型执行预先加载时,默认情况下,Sequelize 也将获取联结表数据. 例如： const Foo = sequelize.define('Foo', { name: DataTypes.TEXT }); const Bar = sequelize.define('Bar', { name: DataTypes.TEXT }); Foo.belongsToMany(Bar, { through: 'Foo_Bar' }); Bar.belongsToMany(Foo, { through: 'Foo_Bar' }); await sequelize.sync(); const foo = await Foo.create({ name: 'foo' }); const bar = await Bar.create({ name: 'bar' }); await foo.addBar(bar); const fetchedFoo = await Foo.findOne({ include: Bar }); console.log(JSON.stringify(fetchedFoo, null, 2)); 输出: { \"id\": 1, \"name\": \"foo\", \"Bars\": [ { \"id\": 1, \"name\": \"bar\", \"Foo_Bar\": { \"FooId\": 1, \"BarId\": 1 } } ] } 请注意,每个预先加载到 Bars 属性中的 bar 实例都有一个名为 Foo_Bar 的额外属性,它是联结模型的相关 Sequelize 实例. 默认情况下,Sequelize 从联结表中获取所有属性,以构建此额外属性. 然而,你可以指定要获取的属性. 这是通过在包含的 through 参数中应用 attributes 参数来完成的. 例如： Foo.findAll({ include: [{ model: Bar, through: { attributes: [/* 在此处列出所需的属性 */] } }] }); 如果你不需要联结表中的任何内容,则可以在 include 选项的 through 内显式地为 attributes 参数提供一个空数组,在这种情况下,将不会获取任何内容,甚至不会创建额外的属性： Foo.findOne({ include: { model: Bar, through: { attributes: [] } } }); 输出: { \"id\": 1, \"name\": \"foo\", \"Bars\": [ { \"id\": 1, \"name\": \"bar\" } ] } 每当包含 \"多对多\" 关系中的模型时,也可以在联结表上应用过滤器. 这是通过在 include 的 through 参数中应用 where 参数来完成的. 例如： User.findAll({ include: [{ model: Project, through: { where: { // 这里,`completed` 是联结表上的一列 completed: true } } }] }); 生成 SQL (使用 SQLite): SELECT `User`.`id`, `User`.`name`, `Projects`.`id` AS `Projects.id`, `Projects`.`name` AS `Projects.name`, `Projects->User_Project`.`completed` AS `Projects.User_Project.completed`, `Projects->User_Project`.`UserId` AS `Projects.User_Project.UserId`, `Projects->User_Project`.`ProjectId` AS `Projects.User_Project.ProjectId` FROM `Users` AS `User` LEFT OUTER JOIN `User_Projects` AS `Projects->User_Project` ON `User`.`id` = `Projects->User_Project`.`UserId` LEFT OUTER JOIN `Projects` AS `Projects` ON `Projects`.`id` = `Projects->User_Project`.`ProjectId` AND `Projects->User_Project`.`completed` = 1; 包括一切 要包括所有关联的模型,可以使用 all 和 nested 参数： // 提取与用户关联的所有模型 User.findAll({ include: { all: true }}); // 递归获取与用户及其嵌套关联关联的所有模型 User.findAll({ include: { all: true, nested: true }}); 包括软删除的记录 如果你想加载软删除的记录,可以通过将 include.paranoid 设置为 false 来实现： User.findAll({ include: [{ model: Tool, as: 'Instruments', where: { size: { [Op.ne]: 'small' } }, paranoid: false }] }); 排序预先加载的关联 当你想将 ORDER 子句应用于预先加载的模型时,必须对扩展数组使用顶层 order 参数,从要排序的嵌套模型开始. 通过示例可以更好地理解这一点. Company.findAll({ include: Division, order: [ // 我们从要排序的模型开始排序数组 [Division, 'name', 'ASC'] ] }); Company.findAll({ include: Division, order: [ [Division, 'name', 'DESC'] ] }); Company.findAll({ // 如果包含使用别名... include: { model: Division, as: 'Div' }, order: [ // ...我们在排序数组的开头使用来自 `include` 的相同语法 [{ model: Division, as: 'Div' }, 'name', 'DESC'] ] }); Company.findAll({ // 如果我们包含嵌套在多个级别中... include: { model: Division, include: Department }, order: [ // ... 我们在排序数组的开头复制需要的 include 链 [Division, Department, 'name', 'DESC'] ] }); 对于多对多关系,你还可以按联结表中的属性进行排序.例如,假设我们在 Division 和 Department 之间存在多对多关系,联结模型为 DepartmentDivision, 你可以这样: Company.findAll({ include: { model: Division, include: Department }, order: [ [Division, DepartmentDivision, 'name', 'ASC'] ] }); 在以上所有示例中,你已经注意到在顶层使用了 order 参数. 但是在separate: true 时,order 也可以在 include 参数中使用. 在这种情况下,用法如下： // 这仅能用于 `separate: true` (反过来仅适用于 HasMany 关系). User.findAll({ include: { model: Post, separate: true, order: [ ['createdAt', 'DESC'] ] } }); 涉及子查询的复杂排序 查看子查询指南上的示例,了解如何使用子查询来协助更复杂的排序. 嵌套的预先加载 你可以使用嵌套的预先加载来加载相关模型的所有相关模型： const users = await User.findAll({ include: { model: Tool, as: 'Instruments', include: { model: Teacher, include: [ /* ... */ ] } } }); console.log(JSON.stringify(users, null, 2)); 输出: [{ \"name\": \"John Doe\", \"id\": 1, \"Instruments\": [{ // 1:M 和 N:M 关联 \"name\": \"Scissor\", \"id\": 1, \"userId\": 1, \"Teacher\": { // 1:1 关联 \"name\": \"Jimi Hendrix\" } }] }] 这将产生一个外部连接. 但是,相关模型上的 where 子句将创建内部联接,并且仅返回具有匹配子模型的实例. 要返回所有父实例,你应该添加 required: false. User.findAll({ include: [{ model: Tool, as: 'Instruments', include: [{ model: Teacher, where: { school: \"Woodstock Music School\" }, required: false }] }] }); 上面的查询将返回所有用户及其所有乐器,但仅返回与 Woodstock Music School 相关的那些老师. 使用带有 include 的 findAndCountAll findAndCountAll 实用功能支持 include. 仅将标记为 required 的 include 项视为 count. 例如,如果你要查找并统计所有拥有个人资料的用户： User.findAndCountAll({ include: [ { model: Profile, required: true } ], limit: 3 }); 因为 Profile 的 include 已设置为 required,它将导致内部联接,并且仅统计具有个人资料的用户. 如果我们从包含中删除 required,则包含和不包含配置文件的用户都将被计数. 在 include 中添加一个 where 子句会自动使它成为 required： User.findAndCountAll({ include: [ { model: Profile, where: { active: true } } ], limit: 3 }); 上面的查询仅会统计拥有有效个人资料的用户,因为当你在 include 中添加 where 子句时,required 会隐式设置为 true. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"advanced-association-concepts/creating-with-associations.html":{"url":"advanced-association-concepts/creating-with-associations.html","title":"Creating with Associations - 创建关联","keywords":"","body":"Creating with Associations - 创建关联 只要所有元素都是新元素,就可以一步创建带有嵌套关联的实例. 相反,无法执行涉及嵌套对象的更新和删除. 为此,你将必须明确执行每个单独的操作. BelongsTo / HasMany / HasOne 关联 考虑以下模型: class Product extends Model {} Product.init({ title: Sequelize.STRING }, { sequelize, modelName: 'product' }); class User extends Model {} User.init({ firstName: Sequelize.STRING, lastName: Sequelize.STRING }, { sequelize, modelName: 'user' }); class Address extends Model {} Address.init({ type: DataTypes.STRING, line1: Sequelize.STRING, line2: Sequelize.STRING, city: Sequelize.STRING, state: Sequelize.STRING, zip: Sequelize.STRING, }, { sequelize, modelName: 'address' }); // 我们保存关联设置调用的返回值,以便以后使用 Product.User = Product.belongsTo(User); User.Addresses = User.hasMany(Address); // 也适用于 `hasOne` 一个新的 Product,User 和一个或多个 Address 可以按以下步骤一步创建： return Product.create({ title: 'Chair', user: { firstName: 'Mick', lastName: 'Broadstone', addresses: [{ type: 'home', line1: '100 Main St.', city: 'Austin', state: 'TX', zip: '78704' }] } }, { include: [{ association: Product.User, include: [ User.Addresses ] }] }); 观察 Product.create 调用中 include 参数的用法. 这对于 Sequelize 理解与关联一起创建的内容很有必要. 注意：这里,我们的用户模型称为user,小写的u-这意味着对象中的属性也应为user. 如果给sequelize.define的名称是User,则对象中的 key 也应该是User. 对于 addresses 也是如此,除了它是 hasMany 关联的复数形式. 一个别名 BelongsTo 关联 可以扩展前面的示例以支持关联别名. const Creator = Product.belongsTo(User, { as: 'creator' }); return Product.create({ title: 'Chair', creator: { firstName: 'Matt', lastName: 'Hansen' } }, { include: [ Creator ] }); HasMany / BelongsToMany 关联 让我们介绍将产品与许多标签关联的功能. 设置模型如下所示： class Tag extends Model {} Tag.init({ name: Sequelize.STRING }, { sequelize, modelName: 'tag' }); Product.hasMany(Tag); // 也适用于 `belongsToMany`. 现在,我们可以通过以下方式创建具有多个标签的产品： Product.create({ id: 1, title: 'Chair', tags: [ { name: 'Alpha'}, { name: 'Beta'} ] }, { include: [ Tag ] }) 并且,我们可以修改此示例以支持别名： const Categories = Product.hasMany(Tag, { as: 'categories' }); Product.create({ id: 1, title: 'Chair', categories: [ { id: 1, name: 'Alpha' }, { id: 2, name: 'Beta' } ] }, { include: [{ association: Categories, as: 'categories' }] }) 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"advanced-association-concepts/advanced-many-to-many.html":{"url":"advanced-association-concepts/advanced-many-to-many.html","title":"Advanced M:N Associations - 高级 M:N 关联","keywords":"","body":"Advanced M:N Associations - 高级 M:N 关联 阅读本指南之前,请确保已阅读 关联指南. 让我们从 User 和 Profile 之间的多对多关系示例开始. const User = sequelize.define('user', { username: DataTypes.STRING, points: DataTypes.INTEGER }, { timestamps: false }); const Profile = sequelize.define('profile', { name: DataTypes.STRING }, { timestamps: false }); 定义多对多关系的最简单方法是： User.belongsToMany(Profile, { through: 'User_Profiles' }); Profile.belongsToMany(User, { through: 'User_Profiles' }); 通过将字符串传递给上面的 through,我们要求 Sequelize 自动生成名为 User_Profiles 的模型作为 联结表,该模型只有两列： userId 和 profileId. 在这两个列上将建立一个复合唯一键. 我们还可以为自己定义一个模型,以用作联结表. const User_Profile = sequelize.define('User_Profile', {}, { timestamps: false }); User.belongsToMany(Profile, { through: User_Profile }); Profile.belongsToMany(User, { through: User_Profile }); 以上具有完全相同的效果. 注意,我们没有在 User_Profile 模型上定义任何属性. 我们将其传递给 belongsToMany 调用的事实告诉 sequelize 自动创建两个属性 userId 和 profileId,就像其他关联一样,也会导致 Sequelize 自动向其中一个涉及的模型添加列. 然而,自己定义模型有几个优点. 例如,我们可以在联结表中定义更多列： const User_Profile = sequelize.define('User_Profile', { selfGranted: DataTypes.BOOLEAN }, { timestamps: false }); User.belongsToMany(Profile, { through: User_Profile }); Profile.belongsToMany(User, { through: User_Profile }); 这样,我们现在可以在联结表中跟踪额外的信息,即 selfGranted 布尔值. 例如,当调用 user.addProfile() 时,我们可以使用 through 参数传递额外列的值. 示例: const amidala = await User.create({ username: 'p4dm3', points: 1000 }); const queen = await Profile.create({ name: 'Queen' }); await amidala.addProfile(queen, { through: { selfGranted: false } }); const result = await User.findOne({ where: { username: 'p4dm3' }, include: Profile }); console.log(result); 输出: { \"id\": 4, \"username\": \"p4dm3\", \"points\": 1000, \"profiles\": [ { \"id\": 6, \"name\": \"queen\", \"User_Profile\": { \"userId\": 4, \"profileId\": 6, \"selfGranted\": false } } ] } 你也可以在单个 create 调用中创建所有关系. 示例: const amidala = await User.create({ username: 'p4dm3', points: 1000, profiles: [{ name: 'Queen', User_Profile: { selfGranted: true } }] }, { include: Profile }); const result = await User.findOne({ where: { username: 'p4dm3' }, include: Profile }); console.log(result); 输出: { \"id\": 1, \"username\": \"p4dm3\", \"points\": 1000, \"profiles\": [ { \"id\": 1, \"name\": \"Queen\", \"User_Profile\": { \"selfGranted\": true, \"userId\": 1, \"profileId\": 1 } } ] } 你可能已经注意到 User_Profiles 表中没有 id 字段. 如上所述,它具有复合唯一键. 该复合唯一密钥的名称由 Sequelize 自动选择,但可以使用 uniqueKey 参数进行自定义： User.belongsToMany(Profile, { through: User_Profiles, uniqueKey: 'my_custom_unique' }); 如果需要的话,另一种可能是强制联结表像其他标准表一样具有主键. 为此,只需在模型中定义主键: const User_Profile = sequelize.define('User_Profile', { id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true, allowNull: false }, selfGranted: DataTypes.BOOLEAN }, { timestamps: false }); User.belongsToMany(Profile, { through: User_Profile }); Profile.belongsToMany(User, { through: User_Profile }); 上面的代码当然仍然会创建两列 userId 和 profileId,但是模型不会在其上设置复合唯一键,而是将其 id 列用作主键. 其他一切仍然可以正常工作. 联结表与普通表以及\"超级多对多关联\" 现在,我们将比较上面显示的最后一个\"多对多\"设置与通常的\"一对多\"关系的用法,以便最后得出 超级多对多关系 的概念作为结论. 模型回顾 (有少量重命名) 为了使事情更容易理解,让我们将 User_Profile 模型重命名为 grant. 请注意,所有操作均与以前相同. 我们的模型是： const User = sequelize.define('user', { username: DataTypes.STRING, points: DataTypes.INTEGER }, { timestamps: false }); const Profile = sequelize.define('profile', { name: DataTypes.STRING }, { timestamps: false }); const Grant = sequelize.define('grant', { id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true, allowNull: false }, selfGranted: DataTypes.BOOLEAN }, { timestamps: false }); 我们使用 Grant 模型作为联结表在 User 和 Profile 之间建立了多对多关系： User.belongsToMany(Profile, { through: Grant }); Profile.belongsToMany(User, { through: Grant }); 这会自动将 userId 和 profileId 列添加到 Grant 模型中. 注意: 如上所示,我们选择强制 grant 模型具有单个主键(通常称为 id). 对于 超级多对多关系(即将定义),这是必需的. 改用一对多关系 除了建立上面定义的多对多关系之外,如果我们执行以下操作怎么办？ // 在 User 和 Grant 之间设置一对多关系 User.hasMany(Grant); Grant.belongsTo(User); // 在Profile 和 Grant 之间也设置一对多关系 Profile.hasMany(Grant); Grant.belongsTo(Profile); 结果基本相同！ 这是因为 User.hasMany(Grant) 和 Profile.hasMany(Grant) 会分别自动将 userId 和 profileId 列添加到 Grant 中. 这表明一个多对多关系与两个一对多关系没有太大区别. 数据库中的表看起来相同. 唯一的区别是你尝试使用 Sequelize 执行预先加载时. // 使用多对多方法,你可以: User.findAll({ include: Profile }); Profile.findAll({ include: User }); // However, you can't do: User.findAll({ include: Grant }); Profile.findAll({ include: Grant }); Grant.findAll({ include: User }); Grant.findAll({ include: Profile }); // 另一方面,通过双重一对多方法,你可以: User.findAll({ include: Grant }); Profile.findAll({ include: Grant }); Grant.findAll({ include: User }); Grant.findAll({ include: Profile }); // However, you can't do: User.findAll({ include: Profile }); Profile.findAll({ include: User }); // 尽管你可以使用嵌套 include 来模拟那些,如下所示: User.findAll({ include: { model: Grant, include: Profile } }); // 这模拟了 `User.findAll({ include: Profile })`, // 但是生成的对象结构有些不同. // 原始结构的格式为 `user.profiles[].grant`, // 而模拟结构的格式为 `user.grants[].profiles[]`. 两全其美：超级多对多关系 我们可以简单地组合上面显示的两种方法！ // 超级多对多关系 User.belongsToMany(Profile, { through: Grant }); Profile.belongsToMany(User, { through: Grant }); User.hasMany(Grant); Grant.belongsTo(User); Profile.hasMany(Grant); Grant.belongsTo(Profile); 这样,我们可以进行各种预先加载： // 全部可以使用: User.findAll({ include: Profile }); Profile.findAll({ include: User }); User.findAll({ include: Grant }); Profile.findAll({ include: Grant }); Grant.findAll({ include: User }); Grant.findAll({ include: Profile }); 我们甚至可以执行各种深层嵌套的 include： User.findAll({ include: [ { model: Grant, include: [User, Profile] }, { model: Profile, include: { model: User, include: { model: Grant, include: [User, Profile] } } } ] }); 别名和自定义键名 与其他关系类似,可以为多对多关系定义别名. 在继续之前,请回顾关联指南上的 belongsTo 别名示例. 请注意,在这种情况下,定义关联影响 include 完成方式(即传递关联名称)和 Sequelize 为外键选择的名称(在该示例中,leaderId 是在 Ship 模型上创建的) . 为一个 belongsToMany 关联定义一个别名也会影响 include 执行的方式： Product.belongsToMany(Category, { as: 'groups', through: 'product_categories' }); Category.belongsToMany(Product, { as: 'items', through: 'product_categories' }); // [...] await Product.findAll({ include: Category }); // 这无法使用 await Product.findAll({ // 通过别名这可以使用 include: { model: Category, as: 'groups' } }); await Product.findAll({ include: 'groups' }); // 这也可以使用 但是,在此处定义别名与外键名称无关. 联结表中创建的两个外键的名称仍由 Sequelize 基于关联的模型的名称构造. 通过检查上面示例中的穿透表生成的 SQL,可以很容易看出这一点： CREATE TABLE IF NOT EXISTS `product_categories` ( `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, `productId` INTEGER NOT NULL REFERENCES `products` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, `categoryId` INTEGER NOT NULL REFERENCES `categories` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, PRIMARY KEY (`productId`, `categoryId`) ); 我们可以看到外键是 productId 和 categoryId. 要更改这些名称,Sequelize 分别接受参数 foreignKey 和 otherKey(即,foreignKey 定义联结关系中源模型的 key,而 otherKey 定义目标模型中的 key)： Product.belongsToMany(Category, { through: 'product_categories', foreignKey: 'objectId', // 替换 `productId` otherKey: 'typeId' // 替换 `categoryId` }); Category.belongsToMany(Product, { through: 'product_categories', foreignKey: 'typeId', // 替换 `categoryId` otherKey: 'objectId' // 替换 `productId` }); 生成 SQL: CREATE TABLE IF NOT EXISTS `product_categories` ( `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, `objectId` INTEGER NOT NULL REFERENCES `products` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, `typeId` INTEGER NOT NULL REFERENCES `categories` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, PRIMARY KEY (`objectId`, `typeId`) ); 如上所示,当使用两个 belongsToMany 调用定义多对多关系时(这是标准方式),应在两个调用中适当地提供 foreignKey 和 otherKey 参数. 如果仅在一个调用中传递这些参数,那么 Sequelize 行为将不可靠. 自参照 Sequelize 直观地支持自参照多对多关系： Person.belongsToMany(Person, { as: 'Children', through: 'PersonChildren' }) // 这将创建表 PersonChildren,该表存储对象的 ID. 从联结表中指定属性 默认情况下,当预先加载多对多关系时,Sequelize 将以以下结构返回数据(基于本指南中的第一个示例)： // User.findOne({ include: Profile }) { \"id\": 4, \"username\": \"p4dm3\", \"points\": 1000, \"profiles\": [ { \"id\": 6, \"name\": \"queen\", \"grant\": { \"userId\": 4, \"profileId\": 6, \"selfGranted\": false } } ] } 注意,外部对象是一个 User,它具有一个名为 profiles 的字段,该字段是 Profile 数组,因此每个 Profile 都带有一个名为 grant 的额外字段,这是一个 Grant 实例.当从多对多关系预先加载时,这是 Sequelize 创建的默认结构. 但是,如果只需要联结表的某些属性,则可以在 attributes 参数中为数组提供所需的属性. 例如,如果只需要穿透表中的 selfGranted 属性： User.findOne({ include: { model: Profile, through: { attributes: ['selfGranted'] } } }); 输出: { \"id\": 4, \"username\": \"p4dm3\", \"points\": 1000, \"profiles\": [ { \"id\": 6, \"name\": \"queen\", \"grant\": { \"selfGranted\": false } } ] } 如果你根本不想使用嵌套的 grant 字段,请使用 attributes: []： User.findOne({ include: { model: Profile, through: { attributes: [] } } }); 输出: { \"id\": 4, \"username\": \"p4dm3\", \"points\": 1000, \"profiles\": [ { \"id\": 6, \"name\": \"queen\" } ] } 如果你使用 mixins(例如 user.getProfiles())而不是查找器方法(例如 User.findAll()),则必须使用 joinTableAttributes 参数： someUser.getProfiles({ joinTableAttributes: ['selfGranted'] }); 输出: [ { \"id\": 6, \"name\": \"queen\", \"grant\": { \"selfGranted\": false } } ] 多对多对多关系及更多 思考你正在尝试为游戏锦标赛建模. 有玩家和团队. 团队玩游戏. 然而,玩家可以在锦标赛中(但不能在比赛中间)更换团队. 因此,给定一个特定的游戏,有某些团队参与该游戏,并且每个团队都有一组玩家(针对该游戏). 因此,我们首先定义三个相关模型： const Player = sequelize.define('Player', { username: DataTypes.STRING }); const Team = sequelize.define('Team', { name: DataTypes.STRING }); const Game = sequelize.define('Game', { name: DataTypes.INTEGER }); 现在的问题是：如何关联它们？ 首先,我们注意到： 一个游戏有许多与之相关的团队(正在玩该游戏的团队); 一个团队可能参加了许多比赛. 以上观察表明,我们需要在 Game 和 Team 之间建立多对多关系. 让我们使用本指南前面解释的超级多对多关系： // Game 与 Team 之间的超级多对多关系 const GameTeam = sequelize.define('GameTeam', { id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true, allowNull: false } }); Team.belongsToMany(Game, { through: GameTeam }); Game.belongsToMany(Team, { through: GameTeam }); GameTeam.belongsTo(Game); GameTeam.belongsTo(Team); Game.hasMany(GameTeam); Team.hasMany(GameTeam); 关于玩家的部分比较棘手. 我们注意到,组成一个团队的一组球员不仅取决于团队,还取决于正在考虑哪个游戏. 因此,我们不希望玩家与团队之间存在多对多关系. 我们也不希望玩家与游戏之间存在多对多关系. 除了将玩家与任何这些模型相关联之外,我们需要的是玩家与 团队－游戏约束 之类的关联,因为这是一对(团队加游戏)来定义哪些玩家属于那里 .因此,我们正在寻找的正是联结模型GameTeam本身！并且,我们注意到,由于给定的 游戏-团队 指定了许多玩家,而同一位玩家可以参与许多 游戏-团队,因此我们需要玩家之间的多对多关系和GameTeam！ 为了提供最大的灵活性,让我们在这里再次使用\"超级多对多\"关系构造： // Player 与 GameTeam 之间的超级多对多关系 const PlayerGameTeam = sequelize.define('PlayerGameTeam', { id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true, allowNull: false } }); Player.belongsToMany(GameTeam, { through: PlayerGameTeam }); GameTeam.belongsToMany(Player, { through: PlayerGameTeam }); PlayerGameTeam.belongsTo(Player); PlayerGameTeam.belongsTo(GameTeam); Player.hasMany(PlayerGameTeam); GameTeam.hasMany(PlayerGameTeam); 上面的关联正是我们想要的. 这是一个完整的可运行示例： const { Sequelize, Op, Model, DataTypes } = require('sequelize'); const sequelize = new Sequelize('sqlite::memory:', { define: { timestamps: false } // 在这个例子中只是为了减少混乱 }); const Player = sequelize.define('Player', { username: DataTypes.STRING }); const Team = sequelize.define('Team', { name: DataTypes.STRING }); const Game = sequelize.define('Game', { name: DataTypes.INTEGER }); // 我们在 Game 和 Team 游戏和团队之间应用超级多对多关系 const GameTeam = sequelize.define('GameTeam', { id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true, allowNull: false } }); Team.belongsToMany(Game, { through: GameTeam }); Game.belongsToMany(Team, { through: GameTeam }); GameTeam.belongsTo(Game); GameTeam.belongsTo(Team); Game.hasMany(GameTeam); Team.hasMany(GameTeam); // 我们在 Player 和 GameTeam 游戏和团队之间应用超级多对多关系 const PlayerGameTeam = sequelize.define('PlayerGameTeam', { id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true, allowNull: false } }); Player.belongsToMany(GameTeam, { through: PlayerGameTeam }); GameTeam.belongsToMany(Player, { through: PlayerGameTeam }); PlayerGameTeam.belongsTo(Player); PlayerGameTeam.belongsTo(GameTeam); Player.hasMany(PlayerGameTeam); GameTeam.hasMany(PlayerGameTeam); (async () => { await sequelize.sync(); await Player.bulkCreate([ { username: 's0me0ne' }, { username: 'empty' }, { username: 'greenhead' }, { username: 'not_spock' }, { username: 'bowl_of_petunias' } ]); await Game.bulkCreate([ { name: 'The Big Clash' }, { name: 'Winter Showdown' }, { name: 'Summer Beatdown' } ]); await Team.bulkCreate([ { name: 'The Martians' }, { name: 'The Earthlings' }, { name: 'The Plutonians' } ]); // 让我们开始定义哪些球队参加了哪些比赛. // 这可以通过几种方式来完成,例如在每个游戏上调用`.setTeams`. // 但是,为简便起见,我们将直接使用 `create` 调用, // 直接引用我们想要的 ID. 我们知道 ID 是从 1 开始的. await GameTeam.bulkCreate([ { GameId: 1, TeamId: 1 }, // 该 GameTeam 将获得 id 1 { GameId: 1, TeamId: 2 }, // 该 GameTeam 将获得 id 2 { GameId: 2, TeamId: 1 }, // 该 GameTeam 将获得 id 3 { GameId: 2, TeamId: 3 }, // 该 GameTeam 将获得 id 4 { GameId: 3, TeamId: 2 }, // 该 GameTeam 将获得 id 5 { GameId: 3, TeamId: 3 } // 该 GameTeam 将获得 id 6 ]); // 现在让我们指定玩家. // 为简便起见,我们仅在第二场比赛(Winter Showdown)中这样做. // 比方说,s0me0ne 和 greenhead 效力于 Martians, // 而 not_spock 和 bowl_of_petunias 效力于 Plutonians: await PlayerGameTeam.bulkCreate([ // 在 'Winter Showdown' (即 GameTeamIds 3 和 4)中: { PlayerId: 1, GameTeamId: 3 }, // s0me0ne played for The Martians { PlayerId: 3, GameTeamId: 3 }, // greenhead played for The Martians { PlayerId: 4, GameTeamId: 4 }, // not_spock played for The Plutonians { PlayerId: 5, GameTeamId: 4 } // bowl_of_petunias played for The Plutonians ]); // 现在我们可以进行查询！ const game = await Game.findOne({ where: { name: \"Winter Showdown\" }, include: { model: GameTeam, include: [ { model: Player, through: { attributes: [] } // 隐藏结果中不需要的 `PlayerGameTeam` 嵌套对象 }, Team ] } }); console.log(`Found game: \"${game.name}\"`); for (let i = 0; i `--- ${p.username}`).join('\\n')); } })(); 输出: Found game: \"Winter Showdown\" - Team \"The Martians\" played game \"Winter Showdown\" with the following players: --- s0me0ne --- greenhead - Team \"The Plutonians\" played game \"Winter Showdown\" with the following players: --- not_spock --- bowl_of_petunias 因此,这就是我们利用超级多对多关系技术在 Sequelize 中实现三个模型之间的 多对多对多 关系的方式！ 这个想法可以递归地应用于甚至更复杂的,多对多对......对多 关系(尽管有时查询可能会变慢). 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"advanced-association-concepts/association-scopes.html":{"url":"advanced-association-concepts/association-scopes.html","title":"Association Scopes - 关联作用域","keywords":"","body":"Association Scopes - 关联作用域 本节涉及关联作用域,它们与模型作用域类似但不相同. 关联作用域既可以放在关联的模型(关联的目标)上,也可以放在多对多关系的联结表中. 概念 与模型作用域如何自动应用于模型静态调用(例如 Model.scope('foo').findAll())类似,关联作用域也是一个规则(更确切地说, 一组默认属性和参数),这些属性会自动应用于模型中的实例调用. 这里,实例调用是指从实例(而不是从 Model 本身)调用的方法调用. Mixins 是实例方法的主要示例(instance.getSomething, instance.setSomething, instance.addSomething 和 instance.createSomething). 关联作用域的行为就像模型作用域一样,在某种意义上,两者都导致将诸如 where 子句之类的内容自动应用到查找器调用; 区别在于,关联作用域不是自动应用于静态finder调用(模型范围就是这种情况),而是自动应用于实例finder调用(例如mixins). 示例 下面显示了模型 Foo 和 Bar 之间的一对多关联的关联范围的基本示例. 设置: const Foo = sequelize.define('foo', { name: DataTypes.STRING }); const Bar = sequelize.define('bar', { status: DataTypes.STRING }); Foo.hasMany(Bar, { scope: { status: 'open' }, as: 'openBars' }); await sequelize.sync(); const myFoo = await Foo.create({ name: \"My Foo\" }); 设置完成后,调用 myFoo.getOpenBars() 会生成以下SQL： SELECT `id`, `status`, `createdAt`, `updatedAt`, `fooId` FROM `bars` AS `bar` WHERE `bar`.`status` = 'open' AND `bar`.`fooId` = 1; 这样,我们可以看到,调用 .getOpenBars() mixin 之后,关联作用域 { status: 'open' } 被自动应用到生成的 SQL 的 WHERE 子句中. 在标准作用域内实现相同的行为 我们可以使用标准作用域实现相同的行为： // Foo.hasMany(Bar, { // scope: { // status: 'open' // }, // as: 'openBars' // }); Bar.addScope('open', { where: { status: 'open' } }); Foo.hasMany(Bar); Foo.hasMany(Bar.scope('open'), { as: 'openBars' }); 使用上面的代码,myFoo.getOpenBars() 产生与上面所示相同的 SQL. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"advanced-association-concepts/polymorphic-associations.html":{"url":"advanced-association-concepts/polymorphic-associations.html","title":"Polymorphic Associations - 多态关联","keywords":"","body":"Polymorphic Associations - 多态关联 注意: 如本指南所述,在 Sequelize 中使用多态关联时应谨慎行事. 不要只是从此处复制粘贴代码,否则你可能会容易出错并在代码中引入错误. 请确保你了解发生了什么. 概念 一个 多态关联 由使用同一外键发生的两个(或多个)关联组成. 例如,考虑模型 Image, Video 和 Comment. 前两个代表用户可能发布的内容. 我们希望允许将评论放在两者中. 这样,我们立即想到建立以下关联： Image 和 Comment 之间的一对多关联: Image.hasMany(Comment); Comment.belongsTo(Image); Video 和 Comment 之间的一对多关联: Video.hasMany(Comment); Comment.belongsTo(Video); 但是,以上操作将导致 Sequelize 在 Comment 表上创建两个外键： ImageId 和 VideoId. 这是不理想的,因为这种结构使评论看起来可以同时附加到一个图像和一个视频上,这是不正确的. 取而代之的是,我们真正想要的是一个多态关联,其中一个 Comment 指向一个 可评论,它是表示 Image 或 Video 之一的抽象多态实体. 在继续配置此类关联之前,让我们看看如何使用它： const image = await Image.create({ url: \"https://placekitten.com/408/287\" }); const comment = await image.createComment({ content: \"Awesome!\" }); console.log(comment.commentableId === image.id); // true // 我们还可以检索与评论关联的可评论类型. // 下面显示了相关的可注释实例的模型名称. console.log(comment.commentableType); // \"Image\" // 我们可以使用多态方法来检索相关的可评论内容, // 而不必关心它是图像还是视频. const associatedCommentable = await comment.getCommentable(); // 在此示例中,`associatedCommentable` 与 `image` 是同一件事： const isDeepEqual = require('deep-equal'); console.log(isDeepEqual(image, commentable)); // true 配置一对多多态关联 要为上述示例(这是一对多多态关联的示例)设置多态关联,我们需要执行以下步骤： 在 Comment 模型中定义一个名为 commentableType 的字符串字段; 在 Image/Video 和 Comment 之间定义 hasMany 和 belongsTo 关联: 禁用约束(即使用 { constraints: false }),因为同一个外键引用了多个表; 指定适当的 关联作用域; 为了适当地支持延迟加载,请在 Comment 模型上定义一个名为 getCommentable 的新实例方法,该方法在后台调用正确的 mixin 来获取适当的注释对象; 为了正确支持预先加载,请在 Comment 模型上定义一个 afterFind hook,该 hook 将在每个实例中自动填充 commentable 字段; 为了防止预先加载的 bug/错误,你还可以在相同的 afterFind hook 中从 Comment 实例中删除具体字段 image 和 video,仅保留抽象的 commentable 字段可用. 这是一个示例: // Helper 方法 const uppercaseFirst = str => `${str[0].toUpperCase()}${str.substr(1)}`; class Image extends Model {} Image.init({ title: DataTypes.STRING, url: DataTypes.STRING }, { sequelize, modelName: 'image' }); class Video extends Model {} Video.init({ title: DataTypes.STRING, text: DataTypes.STRING }, { sequelize, modelName: 'video' }); class Comment extends Model { getCommentable(options) { if (!this.commentableType) return Promise.resolve(null); const mixinMethodName = `get${uppercaseFirst(this.commentableType)}`; return this[mixinMethodName](options); } } Comment.init({ title: DataTypes.STRING, commentableId: DataTypes.INTEGER, commentableType: DataTypes.STRING }, { sequelize, modelName: 'comment' }); Image.hasMany(Comment, { foreignKey: 'commentableId', constraints: false, scope: { commentableType: 'image' } }); Comment.belongsTo(Image, { foreignKey: 'commentableId', constraints: false }); Video.hasMany(Comment, { foreignKey: 'commentableId', constraints: false, scope: { commentableType: 'video' } }); Comment.belongsTo(Video, { foreignKey: 'commentableId', constraints: false }); Comment.addHook(\"afterFind\", findResult => { if (!Array.isArray(findResult)) findResult = [findResult]; for (const instance of findResult) { if (instance.commentableType === \"image\" && instance.image !== undefined) { instance.commentable = instance.image; } else if (instance.commentableType === \"video\" && instance.video !== undefined) { instance.commentable = instance.video; } // 防止错误: delete instance.image; delete instance.dataValues.image; delete instance.video; delete instance.dataValues.video; } }); 由于 commentableId 列引用了多个表(本例中为两个表),因此我们无法向其添加 REFERENCES 约束. 这就是为什么使用 constraints: false 参数的原因. 注意,在上面的代码中: Image -> Comment 关联定义了一个关联作用域: { commentableType: 'image' } Video -> Comment 关联定义了一个关联作用域: { commentableType: 'video' } 使用关联函数时,这些作用域会自动应用(如关联作用域指南中所述). 以下是一些示例及其生成的 SQL 语句： image.getComments(): SELECT \"id\", \"title\", \"commentableType\", \"commentableId\", \"createdAt\", \"updatedAt\" FROM \"comments\" AS \"comment\" WHERE \"comment\".\"commentableType\" = 'image' AND \"comment\".\"commentableId\" = 1; 在这里我们可以看到 `comment`.`commentableType` = 'image' 已自动添加到生成的 SQL 的 WHERE 子句中. 这正是我们想要的行为. image.createComment({ title: 'Awesome!' }): INSERT INTO \"comments\" ( \"id\", \"title\", \"commentableType\", \"commentableId\", \"createdAt\", \"updatedAt\" ) VALUES ( DEFAULT, 'Awesome!', 'image', 1, '2018-04-17 05:36:40.454 +00:00', '2018-04-17 05:36:40.454 +00:00' ) RETURNING *; image.addComment(comment): UPDATE \"comments\" SET \"commentableId\"=1, \"commentableType\"='image', \"updatedAt\"='2018-04-17 05:38:43.948 +00:00' WHERE \"id\" IN (1) 多态延迟加载 Comment 上的 getCommentable 实例方法为延迟加载相关的 commentable 提供了一种抽象 - 无论注释属于 Image 还是 Video,都可以工作. 通过简单地将 commentableType 字符串转换为对正确的 mixin( getImage 或 getVideo)的调用即可工作. 注意上面的 getCommentable 实现： 不存在关联时返回 null; 允许你将参数对象传递给 getCommentable(options),就像其他任何标准 Sequelize 方法一样. 对于示例,这对于指定 where 条件或 include 条件很有用. 多态预先加载 现在,我们希望对一个(或多个)注释执行关联的可评论对象的多态预先加载. 我们想要实现类似以下的东西： const comment = await Comment.findOne({ include: [ /* ... */ ] }); console.log(comment.commentable); // 这是我们的目标 解决的办法是告诉 Sequelize 同时包含图像和视频,以便上面定义的 afterFind hook可以完成工作,并自动向实例对象添加 commentable 字段,以提供所需的抽象. 示例: const comments = await Comment.findAll({ include: [Image, Video] }); for (const comment of comments) { const message = `Found comment #${comment.id} with ${comment.commentableType} commentable:`; console.log(message, comment.commentable.toJSON()); } 输出: Found comment #1 with image commentable: { id: 1, title: 'Meow', url: 'https://placekitten.com/408/287', createdAt: 2019-12-26T15:04:53.047Z, updatedAt: 2019-12-26T15:04:53.047Z } 注意 - 可能无效的 预先/延迟 加载! 注释 Foo,其 commentableId 为 2,而 commentableType 为 image. 然后 Image A 和 Video X 的 ID 都恰好等于 2.从概念上讲,很明显,Video X 与 Foo 没有关联,因为即使其 ID 为 2,Foo 的 commentableType 是 image,而不是 video. 然而,这种区分仅在 Sequelize 的 getCommentable 和我们在上面创建的 hook 执行的抽象级别上进行. 这意味着如果在上述情况下调用 Comment.findAll({ include: Video }),Video X 将被预先加载到 Foo 中. 幸运的是,我们的 afterFind hook将自动删除它,以帮助防止错误. 你了解发生了什么是非常重要的. 防止此类错误的最好方法是 不惜一切代价直接使用具体的访问器和mixin (例如 .image, .getVideo(), .setImage() 等) ,总是喜欢我们创建的抽象,例如 .getCommentable() and .commentable. 如果由于某种原因确实需要访问预先加载的 .image 和 .video 请确保将其包装在类型检查中,例如 comment.commentableType === 'image'. 配置多对多多态关联 在上面的示例中,我们将模型 Image 和 Video 抽象称为 commentables,其中一个 commentable 具有很多注释. 但是,一个给定的注释将属于一个 commentable - 这就是为什么整个情况都是一对多多态关联的原因. 现在,考虑多对多多态关联,而不是考虑注释,我们将考虑标签. 为了方便起见,我们现在将它们称为 taggables,而不是将它们称为 commentables. 一个 taggable 可以具有多个标签,同时一个标签可以放置在多个 taggables 中. 为此设置如下： 明确定义联结模型,将两个外键指定为 tagId 和 taggableId(这样,它是 Tag 与 taggable 抽象概念之间多对多关系的联结模型); 在联结模型中定义一个名为 taggableType 的字符串字段; 定义两个模型之间的 belongsToMany 关联和 标签: 禁用约束 (即, 使用 { constraints: false }), 因为同一个外键引用了多个表; 指定适当的 关联作用域; 在 Tag 模型上定义一个名为 getTaggables 的新实例方法,该方法在后台调用正确的 mixin 来获取适当的 taggables. 实践: class Tag extends Model { getTaggables(options) { const images = await this.getImages(options); const videos = await this.getVideos(options); // 在单个 taggables 数组中合并 images 和 videos return images.concat(videos); } } Tag.init({ name: DataTypes.STRING }, { sequelize, modelName: 'tag' }); // 在这里,我们明确定义联结模型 class Tag_Taggable extends Model {} Tag_Taggable.init({ tagId: { type: DataTypes.INTEGER, unique: 'tt_unique_constraint' }, taggableId: { type: DataTypes.INTEGER, unique: 'tt_unique_constraint', references: null }, taggableType: { type: DataTypes.STRING, unique: 'tt_unique_constraint' } }, { sequelize, modelName: 'tag_taggable' }); Image.belongsToMany(Tag, { through: { model: Tag_Taggable, unique: false, scope: { taggableType: 'image' } }, foreignKey: 'taggableId', constraints: false }); Tag.belongsToMany(Image, { through: { model: Tag_Taggable, unique: false }, foreignKey: 'tagId', constraints: false }); Video.belongsToMany(Tag, { through: { model: Tag_Taggable, unique: false, scope: { taggableType: 'video' } }, foreignKey: 'taggableId', constraints: false }); Tag.belongsToMany(Video, { through: { model: Tag_Taggable, unique: false }, foreignKey: 'tagId', constraints: false }); constraints: false 参数禁用引用约束,因为 taggableId 列引用了多个表,因此我们无法向其添加 REFERENCES 约束. 注意下面: 对 Image -> Tag 关联定义了一个关联范围: { taggableType: 'image' } 对 Video -> Tag 关联定义了一个关联范围: { taggableType: 'video' } 使用关联函数时,将自动应用这些作用域. 以下是一些示例及其生成的 SQL 语句： image.getTags(): SELECT `tag`.`id`, `tag`.`name`, `tag`.`createdAt`, `tag`.`updatedAt`, `tag_taggable`.`tagId` AS `tag_taggable.tagId`, `tag_taggable`.`taggableId` AS `tag_taggable.taggableId`, `tag_taggable`.`taggableType` AS `tag_taggable.taggableType`, `tag_taggable`.`createdAt` AS `tag_taggable.createdAt`, `tag_taggable`.`updatedAt` AS `tag_taggable.updatedAt` FROM `tags` AS `tag` INNER JOIN `tag_taggables` AS `tag_taggable` ON `tag`.`id` = `tag_taggable`.`tagId` AND `tag_taggable`.`taggableId` = 1 AND `tag_taggable`.`taggableType` = 'image'; 在这里我们可以看到 `tag_taggable`.`taggableType` = 'image' 已被自动添加到生成的 SQL 的 WHERE 子句中. 这正是我们想要的行为. tag.getTaggables(): SELECT `image`.`id`, `image`.`url`, `image`.`createdAt`, `image`.`updatedAt`, `tag_taggable`.`tagId` AS `tag_taggable.tagId`, `tag_taggable`.`taggableId` AS `tag_taggable.taggableId`, `tag_taggable`.`taggableType` AS `tag_taggable.taggableType`, `tag_taggable`.`createdAt` AS `tag_taggable.createdAt`, `tag_taggable`.`updatedAt` AS `tag_taggable.updatedAt` FROM `images` AS `image` INNER JOIN `tag_taggables` AS `tag_taggable` ON `image`.`id` = `tag_taggable`.`taggableId` AND `tag_taggable`.`tagId` = 1; SELECT `video`.`id`, `video`.`url`, `video`.`createdAt`, `video`.`updatedAt`, `tag_taggable`.`tagId` AS `tag_taggable.tagId`, `tag_taggable`.`taggableId` AS `tag_taggable.taggableId`, `tag_taggable`.`taggableType` AS `tag_taggable.taggableType`, `tag_taggable`.`createdAt` AS `tag_taggable.createdAt`, `tag_taggable`.`updatedAt` AS `tag_taggable.updatedAt` FROM `videos` AS `video` INNER JOIN `tag_taggables` AS `tag_taggable` ON `video`.`id` = `tag_taggable`.`taggableId` AND `tag_taggable`.`tagId` = 1; 请注意,上述 getTaggables() 的实现允许你将选项对象传递给 getCommentable(options),就像其他任何标准 Sequelize 方法一样. 例如,这对于指定条件或包含条件很有用. 在目标模型上应用作用域 在上面的示例中,scope 参数(例如 scope: { taggableType: 'image' })应用于 联结 模型,而不是 目标 模型,因为它是在 through 下使用的参数. 我们还可以在目标模型上应用关联作用域. 我们甚至可以同时进行. 为了说明这一点,请考虑上述示例在标签和可标记之间的扩展,其中每个标签都有一个状态. 这样,为了获取图像的所有待处理标签,我们可以在 Image 和 Tag 之间建立另一个 belognsToMany 关系,这一次在联结模型上应用作用域,在目标模型上应用另一个作用域： Image.belongsToMany(Tag, { through: { model: Tag_Taggable, unique: false, scope: { taggableType: 'image' } }, scope: { status: 'pending' }, as: 'pendingTags', foreignKey: 'taggableId', constraints: false }); 这样,当调用 image.getPendingTags() 时,将生成以下 SQL 查询： SELECT `tag`.`id`, `tag`.`name`, `tag`.`status`, `tag`.`createdAt`, `tag`.`updatedAt`, `tag_taggable`.`tagId` AS `tag_taggable.tagId`, `tag_taggable`.`taggableId` AS `tag_taggable.taggableId`, `tag_taggable`.`taggableType` AS `tag_taggable.taggableType`, `tag_taggable`.`createdAt` AS `tag_taggable.createdAt`, `tag_taggable`.`updatedAt` AS `tag_taggable.updatedAt` FROM `tags` AS `tag` INNER JOIN `tag_taggables` AS `tag_taggable` ON `tag`.`id` = `tag_taggable`.`tagId` AND `tag_taggable`.`taggableId` = 1 AND `tag_taggable`.`taggableType` = 'image' WHERE ( `tag`.`status` = 'pending' ); 我们可以看到两个作用域都是自动应用的: `tag_taggable`.`taggableType` = 'image' 被自动添加到 INNER JOIN; `tag`.`status` = 'pending' 被自动添加到外部 where 子句. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/dialect-specific-things.html":{"url":"other-topics/dialect-specific-things.html","title":"Dialect-Specific Things - 方言特定事项","keywords":"","body":"Dialect-Specific Things - 方言特定事项 基础连接器库 MySQL Sequelize 对于 MySQL 使用的基础连接器库是 mysql2 软件包(1.5.2 或更高版本). 你可以使用 Sequelize 构造函数中的 dialectOptions 为其提供自定义参数： const sequelize = new Sequelize('database', 'username', 'password', { dialect: 'mysql', dialectOptions: { // 你的 mysql2 参数 } }) dialectOptions 直接传递给 MySQL 连接构造函数. 完整的选项列表可以在 MySQL 文档 中找到. MariaDB Sequelize 对于 MariaDB 使用的基础连接器库是 mariadb 软件包. 你可以使用 Sequelize 构造函数中的 dialectOptions 为其提供自定义参数： const sequelize = new Sequelize('database', 'username', 'password', { dialect: 'mariadb', dialectOptions: { // 你的 mariadb 参数 // connectTimeout: 1000 } }); dialectOptions 直接传递给 MariaDB 连接构造函数. 完整的选项列表可以在 MariaDB 文档 中找到. SQLite Sequelize 对于 SQLite 使用的基础连接器库是 sqlite3 程序包(版本4.0.0或更高版本). 你可以在 Sequelize 构造函数中使用 storage 参数指定存储文件(对于内存中的SQLite实例,请使用 :memory:). 你可以使用 Sequelize 构造函数中的 dialectOptions 为其提供自定义参数： const sequelize = new Sequelize('database', 'username', 'password', { dialect: 'sqlite', storage: 'path/to/database.sqlite' // 或 ':memory:' dialectOptions: { // 你的 sqlite3 参数 } }); 以下字段可以传递给 SQLite dialectOptions: readWriteMode: 设置 SQLite 连接的打开模式. 潜在值由 sqlite3 包提供, 并且能包括 sqlite3.OPEN_READONLY, sqlite3.OPEN_READWRITE 或 sqlite3.OPEN_CREATE. 查阅 SQLite C 接口文档 以获取更多详细信息. PostgreSQL Sequelize 对于 PostgreSQL 使用的基础连接器库是 pg 软件包(版本7.0.0或更高版本). 还需要模块 pg-hstore. 你可以使用 Sequelize 构造函数中的 dialectOptions 为其提供自定义参数： const sequelize = new Sequelize('database', 'username', 'password', { dialect: 'postgres', dialectOptions: { // 你的 pg 参数 } }); 以下字段可以传递给 Postgres dialectOptions: application_name: pg_stat_activity 中的应用程序名称. 参阅 Postgres 文档 获取更多详细信息. ssl: SSL 参数. 参阅 pg 文档 获取更多详细信息. client_encoding: // 设置 'auto' 根据客户端 LC_CTYPE 环境变量确定语言环境. 参阅 Postgres 文档 获取更多详细信息. keepAlive: 启用 TCP KeepAlive 的布尔值. 参阅 pg 更新记录 获取更多详细信息. statement_timeout: 在设定的时间后超时查询(以毫秒为单位). 添加于 pg v7.3. 参阅 Postgres 文档 获取更多详细信息. idle_in_transaction_session_timeout: 终止超过指定持续时间(以毫秒为单位)的空闲事务会话. 参阅 Postgres 文档 获取更多详细信息. 要通过 Unix 域套接字进行连接,请在 host 参数中指定套接字目录的路径. 套接字路径必须以 / 开头. const sequelize = new Sequelize('database', 'username', 'password', { dialect: 'postgres', host: '/path/to/socket_directory' }); sequelize 中默认的 client_min_messages 配置是 WARNING. Redshift 大多数配置与上面的 PostgreSQL 相同. Redshift 不支持 client_min_messages, 需要 'ignore' 跳过配置: const sequelize = new Sequelize('database', 'username', 'password', { dialect: 'postgres', dialectOptions: { // 你的 pg 参数 // ... clientMinMessages: 'ignore' // 不区分大小写 } }); MSSQL 支持的 MS SQL 版本从 MS SQL 2017（版本 14）到最新版本. Tedious Sequelize 默认用于 MSSQL 的基础连接器库是 tedious npm 软件包(版本6.0.0或更高版本). 你可以使用 Sequelize 构造函数中的 dialectOptions.options 为其提供自定义参数： const sequelize = new Sequelize('database', 'username', 'password', { dialect: 'mssql', dialectOptions: { // 观察 MSSQL 这个嵌套的 `options` 字段 options: { // 你的 tedious 参数 useUTC: false, dateFirst: 1 } } }); 完整的选项列表可以在 tedious 文档 中找到. MSSQL 域账户 为了连接域帐户,请使用以下格式. const sequelize = new Sequelize('database', null, null, { dialect: 'mssql', dialectOptions: { authentication: { type: 'ntlm', options: { domain: 'yourDomain', userName: 'username', password: 'password' } }, options: { instanceName: 'SQLEXPRESS' } } }) Snowflake (实验性) Sequelize 用于 Snowflake 的底层连接器库是 snowflake-sdk 包. 为了与帐户连接, 请使用以下格式: const sequelize = new Sequelize('database', null, null, { dialect: 'snowflake', dialectOptions: { // 把你的snowflake帐户放在这里, account: 'myAccount', // my-app.us-east-1 // 下面的选项是可选的 role: 'myRole', warehouse: 'myWarehouse', schema: 'mySchema' }, // 和其他方言一样 username: 'myUserName', password: 'myPassword', database: 'myDatabaseName' }) 注意 没有提供测试沙箱, 因此 snowflake 集成测试不是 pipeline 的一部分. 核心团队也很难进行分类和调试. 这种方言现在需要由 snowflake 用户/社区维护. 用于运行集成测试: # using npm SEQ_ACCOUNT=myAccount SEQ_USER=myUser SEQ_PW=myPassword SEQ_ROLE=myRole SEQ_DB=myDatabaseName SEQ_SCHEMA=mySchema SEQ_WH=myWareHouse npm run test-integration-snowflake # using yarn SEQ_ACCOUNT=myAccount SEQ_USER=myUser SEQ_PW=myPassword SEQ_ROLE=myRole SEQ_DB=myDatabaseName SEQ_SCHEMA=mySchema SEQ_WH=myWareHouse yarn test-integration-snowflake 数据类型: TIMESTAMP WITHOUT TIME ZONE - 仅限 PostgreSQL 如果你使用的是 PostgreSQL TIMESTAMP WITH TIME ZONE,并且需要将其解析为其他时区,请使用 pg 库自己的解析器： require('pg').types.setTypeParser(1114, stringValue => { return new Date(stringValue + '+0000'); // 例如 UTC 偏移量. 使用任何你想要的偏移量. }); 数据类型: ARRAY(ENUM) - 仅限 PostgreSQL Array(Enum)类型需要特殊处理. 每当 Sequelize 与数据库对话时,它都必须使用 ENUM 名称转换数组值. 因此,此枚举名称必须遵循这种格式 enum__. 如果你使用 sync,则将自动生成正确的名称. 表提示 - 仅限 MSSQL tableHint 属性可用于定义表提示. 提示必须是来自 TableHints 的值,并且仅在绝对必要时才使用. 当前每个查询仅支持单个表提示. 表提示通过指定某些参数来覆盖 MSSQL 查询优化器的默认行为. 它们仅影响该子句中引用的表或视图. const { TableHints } = require('sequelize'); Project.findAll({ // 添加表提示 NOLOCK tableHint: TableHints.NOLOCK // 这将生成 SQL 'WITH (NOLOCK)' }) 索引提示 - 仅限 MySQL/MariaDB indexHints 参数可以用来定义索引提示. 提示类型必须是 IndexHints 中的值,并且这些值应引用现有索引. 索引提示将覆盖 MySQL 查询优化器的默认行为. const { IndexHints } = require(\"sequelize\"); Project.findAll({ indexHints: [ { type: IndexHints.USE, values: ['index_project_on_name'] } ], where: { id: { [Op.gt]: 623 }, name: { [Op.like]: 'Foo %' } } }); 上面的代码将生成一个如下所示的 MySQL 查询： SELECT * FROM Project USE INDEX (index_project_on_name) WHERE name LIKE 'FOO %' AND id > 623; Sequelize.IndexHints 包含 USE, FORCE, 和 IGNORE. 参考 Issue #9421 有关原始 API 提案. 引擎 - 仅限 MySQL/MariaDB 模型的默认引擎是 InnoDB. 你可以使用 engine 参数更改模型的引擎(例如,更改为 MyISAM)： const Person = sequelize.define('person', { /* 属性 */ }, { engine: 'MYISAM' }); 像模型定义的每个参数一样,也可以使用 Sequelize 构造函数的 define 参数来全局更改此设置： const sequelize = new Sequelize(db, user, pw, { define: { engine: 'MYISAM' } }) 表注释 - 仅限 MySQL/MariaDB/PostgreSQL 你可以在定义模型时为表指定注释： class Person extends Model {} Person.init({ /* 属性 */ }, { comment: \"I'm a table comment!\", sequelize }) 调用 sync() 时将设置注释. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/transactions.html":{"url":"other-topics/transactions.html","title":"Transactions - 事务","keywords":"","body":"Transactions - 事务 默认情况下,Sequelize 不使用事务. 但是,对于 Sequelize 的生产环境使用,你绝对应该将 Sequelize 配置为使用事务. Sequelize 支持两种使用事务的方式： 非托管事务: 提交和回滚事务应由用户手动完成(通过调用适当的 Sequelize 方法). 托管事务: 如果引发任何错误,Sequelize 将自动回滚事务,否则将提交事务. 另外,如果启用了CLS(连续本地存储),则事务回调中的所有查询将自动接收事务对象. 非托管事务 让我们从一个例子开始: // 首先,我们开始一个事务并将其保存到变量中 const t = await sequelize.transaction(); try { // 然后,我们进行一些调用以将此事务作为参数传递: const user = await User.create({ firstName: 'Bart', lastName: 'Simpson' }, { transaction: t }); await user.addSibling({ firstName: 'Lisa', lastName: 'Simpson' }, { transaction: t }); // 如果执行到此行,且没有引发任何错误. // 我们提交事务. await t.commit(); } catch (error) { // 如果执行到达此行,则抛出错误. // 我们回滚事务. await t.rollback(); } 如上所示,非托管事务 方法要求你在必要时手动提交和回滚事务. 托管事务 托管事务会自动处理提交或回滚事务. 通过将回调传递给 sequelize.transaction 来启动托管事务. 这个回调可以是 async(通常是)的. 在这种情况下,将发生以下情况： Sequelize 将自动开始事务并获得事务对象 t 然后,Sequelize 将执行你提供的回调,并在其中传递 t 如果你的回调抛出错误,Sequelize 将自动回滚事务 如果你的回调成功,Sequelize 将自动提交事务 只有这样,sequelize.transaction 调用才会解决： 解决你的回调的决议 或者,如果你的回调引发错误,则拒绝并抛出错误 示例代码: try { const result = await sequelize.transaction(async (t) => { const user = await User.create({ firstName: 'Abraham', lastName: 'Lincoln' }, { transaction: t }); await user.setShooter({ firstName: 'John', lastName: 'Boothe' }, { transaction: t }); return user; }); // 如果执行到此行,则表示事务已成功提交,`result`是事务返回的结果 // `result` 就是从事务回调中返回的结果(在这种情况下为 `user`) } catch (error) { // 如果执行到此,则发生错误. // 该事务已由 Sequelize 自动回滚！ } 注意,t.commit() 和 t.rollback() 没有被直接调用. 抛出错误以回滚 使用托管事务时,你 不应 手动提交或回滚事务. 如果所有查询都成功(就不引发任何错误而言),但是你仍然想回滚事务,那么你应该自己引发一个错误： await sequelize.transaction(async t => { const user = await User.create({ firstName: 'Abraham', lastName: 'Lincoln' }, { transaction: t }); // 查询成功,但我们仍要回滚！ // 我们手动引发错误,以便 Sequelize 自动处理所有内容. throw new Error(); }); 自动将事务传递给所有查询 在上面的示例中,仍然通过传递 { transaction: t } 作为第二个参数来手动传递事务. 要将事务自动传递给所有查询,你必须安装 cls-hooked (CLS) 模块,并在自己的代码中实例化命名空间： const cls = require('cls-hooked'); const namespace = cls.createNamespace('my-very-own-namespace'); 要启用 CLS,你必须通过使用 sequelize 构造函数的静态方法来告诉 sequelize 使用哪个命名空间： const Sequelize = require('sequelize'); Sequelize.useCLS(namespace); new Sequelize(....); 注意,useCLS() 方法在 构建器 上,而不在 sequelize 实例上. 这意味着所有实例将共享相同的命名空间,并且 CLS 是全有或全无 - 你不能仅对某些实例启用它. CLS 的工作方式类似于用于回调的线程本地存储. 实际上,这意味着不同的回调链可以使用 CLS 命名空间访问局部变量. 启用 CLS 时,sequelize 将在创建新事务时在命名空间上设置 transaction 属性. 由于在回调链中设置的变量是该链的私有变量,因此可以同时存在多个并发事务： sequelize.transaction((t1) => { namespace.get('transaction') === t1; // true }); sequelize.transaction((t2) => { namespace.get('transaction') === t2; // true }); 在大多数情况下,你不需要直接访问 namespace.get('transaction'),因为所有查询都会自动在命名空间上查找事务： sequelize.transaction((t1) => { // 启用 CLS 后,将在事务内部创建用户 return User.create({ name: 'Alice' }); }); 并发/部分事务 你可以在一系列查询中进行并发事务,也可以将某些事务排除在任何事务之外. 使用 transaction 参数来控制查询属于哪个事务： 注意: SQLite 不支持同时多个事务. 启用 CLS sequelize.transaction((t1) => { return sequelize.transaction((t2) => { // 启用 CLS 后,此处的查询默认情况下将使用 t2. // 传递 `transaction` 参数以定义/更改它们所属的事务. return Promise.all([ User.create({ name: 'Bob' }, { transaction: null }), User.create({ name: 'Mallory' }, { transaction: t1 }), User.create({ name: 'John' }) // 这将默认为 t2 ]); }); }); 传递参数 sequelize.transaction 方法接受参数. 对于非托管事务,只需使用 sequelize.transaction(options). 对于托管交易,请使用 sequelize.transaction(options, callback). 隔离级别 启动事务时可能使用的隔离级别： const { Transaction } = require('sequelize'); // 以下是有效的隔离级别: Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED // \"READ UNCOMMITTED\" Transaction.ISOLATION_LEVELS.READ_COMMITTED // \"READ COMMITTED\" Transaction.ISOLATION_LEVELS.REPEATABLE_READ // \"REPEATABLE READ\" Transaction.ISOLATION_LEVELS.SERIALIZABLE // \"SERIALIZABLE\" 默认情况下,sequelize 使用数据库的隔离级别. 如果要使用其他隔离级别,请传入所需的级别作为第一个参数： const { Transaction } = require('sequelize'); await sequelize.transaction({ isolationLevel: Transaction.ISOLATION_LEVELS.SERIALIZABLE }, async (t) => { // 你的代码 }); 你还可以使用 Sequelize 构造函数中的一个参数来全局覆盖 isolationLevel 设置： const { Sequelize, Transaction } = require('sequelize'); const sequelize = new Sequelize('sqlite::memory:', { isolationLevel: Transaction.ISOLATION_LEVELS.SERIALIZABLE }); MSSQL 注意: 因为指定的 isolationLevel 被直接传递给 tedious,所以没有记录 SET ISOLATION LEVEL 查询. 与其他 sequelize 方法一起使用 transaction 参数与大多数其他参数一起使用,通常是方法的第一个参数. 对于带有值的方法,例如 .create,.update() 等.transaction 应该传递给第二个参数. 如果不确定,请参考你使用的方法的 API 文档以确保正确. 示例: await User.create({ name: 'Foo Bar' }, { transaction: t }); await User.findAll({ where: { name: 'Foo Bar' }, transaction: t }); afterCommit hook 一个 transaction 对象允许跟踪它是否以及何时被提交. 可以将 afterCommit hook 添加到托管和非托管事务对象中： // 托管事务: await sequelize.transaction(async (t) => { t.afterCommit(() => { // 你的代码 }); }); // 非托管事务: const t = await sequelize.transaction(); t.afterCommit(() => { // 你的代码 }); await t.commit(); 传递给 afterCommit 的回调可以是 async. 在这种情况下： 对于托管交易：sequelize.transaction 调用将在完成之前等待它; 对于非托管交易：t.commit 调用将在完成之前等待它. 注意: 如果事务回滚,则不会引发 afterCommit hook; afterCommit hook 不修改事务的返回值(与大多数 hook 不同) 你可以将 afterCommit hook 与模型 hook 结合使用,以了解何时保存实例并在事务外部可用 User.afterSave((instance, options) => { if (options.transaction) { // 在事务中保存完成, // 等待事务提交以通知侦听器实例已保存 options.transaction.afterCommit(() => /* 通知 */) return; } // 在事务外保存完成,使调用者可以安全地获取更新的模型 // 通知 }); 锁 可以使用锁执行 transaction 中的查询： return User.findAll({ limit: 1, lock: true, transaction: t1 }); 事务中的查询可以跳过锁定的行： return User.findAll({ limit: 1, lock: true, skipLocked: true, transaction: t2 }); 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/hooks.html":{"url":"other-topics/hooks.html","title":"Hooks - 钩子","keywords":"","body":"Hooks - 钩子 Hooks(也称为生命周期事件)是在执行 sequelize 中的调用之前和之后调用的函数. 例如,如果要在保存之前始终在模型上设置一个值,则可以添加一个 beforeUpdate hook. 注意: 你不能对实例使用 hook. Hook 用于模型. 可用的 hooks Sequelize 提供了很多 hook. 完整列表可以直接在源代码 - lib/hooks.js 中找到. Hooks 触发顺序 下面显示了最常见的 hook 的触发顺序. 注意: 此列表并不详尽. (1) beforeBulkCreate(instances, options) beforeBulkDestroy(options) beforeBulkUpdate(options) (2) beforeValidate(instance, options) [... validation happens ...] (3) afterValidate(instance, options) validationFailed(instance, options, error) (4) beforeCreate(instance, options) beforeDestroy(instance, options) beforeUpdate(instance, options) beforeSave(instance, options) beforeUpsert(values, options) [... creation/update/destruction happens ...] (5) afterCreate(instance, options) afterDestroy(instance, options) afterUpdate(instance, options) afterSave(instance, options) afterUpsert(created, options) (6) afterBulkCreate(instances, options) afterBulkDestroy(options) afterBulkUpdate(options) 声明 Hooks Hook 的参数通过引用传递. 这意味着你可以更改值,这将反映在 insert / update 语句中. 一个 hook 可能包含异步动作 - 在这种情况下,hook 函数应该返回一个 Promise. 当前有三种方法以编程方式添加 hook： // 方法 1 通过 .init() 方法 class User extends Model {} User.init({ username: DataTypes.STRING, mood: { type: DataTypes.ENUM, values: ['happy', 'sad', 'neutral'] } }, { hooks: { beforeValidate: (user, options) => { user.mood = 'happy'; }, afterValidate: (user, options) => { user.username = 'Toni'; } }, sequelize }); // 方法 2 通过 .addHook() 方法 User.addHook('beforeValidate', (user, options) => { user.mood = 'happy'; }); User.addHook('afterValidate', 'someCustomName', (user, options) => { return Promise.reject(new Error(\"I'm afraid I can't let you do that!\")); }); // 方法 3 通过 direct 方法 User.beforeCreate(async (user, options) => { const hashedPassword = await hashPassword(user.password); user.password = hashedPassword; }); User.afterValidate('myHookAfter', (user, options) => { user.username = 'Toni'; }); 删除 hooks 只能删除带有名称参数的 hook. class Book extends Model {} Book.init({ title: DataTypes.STRING }, { sequelize }); Book.addHook('afterCreate', 'notifyUsers', (book, options) => { // ... }); Book.removeHook('afterCreate', 'notifyUsers'); 你可以有许多同名的 hook. 调用 .removeHook() 将删除所有对象. 全局 / 通用 hooks 全局 hook 是所有模型运行的 hook. 它们对于插件特别有用, 并且可以为所有模型定义您想要的行为. 例如允许在您的模型上使用 sequelize.define 自定义时间戳: const User = sequelize.define('User', {}, { tableName: 'users', hooks : { beforeCreate : (record, options) => { record.dataValues.createdAt = new Date().toISOString().replace(/T/, ' ').replace(/\\..+/g, ''); record.dataValues.updatedAt = new Date().toISOString().replace(/T/, ' ').replace(/\\..+/g, ''); }, beforeUpdate : (record, options) => { record.dataValues.updatedAt = new Date().toISOString().replace(/T/, ' ').replace(/\\..+/g, ''); } } }); 它们可以通过多种方式定义, 语义略有不同: 默认 Hooks (在 Sequelize 构造函数参数) const sequelize = new Sequelize(..., { define: { hooks: { beforeCreate() { // 做点什么 } } } }); 这会向所有模型添加一个默认 hook,如果模型未定义自己的 beforeCreate hook,则将运行该 hook： const User = sequelize.define('User', {}); const Project = sequelize.define('Project', {}, { hooks: { beforeCreate() { // 做点其他事 } } }); await User.create({}); // 运行全局 hook await Project.create({}); // 运行自己的 hook (因为全局 hook 被覆盖) 常驻 Hooks (通过 sequelize.addHook) sequelize.addHook('beforeCreate', () => { // 做点什么 }); 无论模型是否指定自己的 beforeCreate hook,该 hook 始终运行. 本地 hook 总是在全局 hook 之前运行： const User = sequelize.define('User', {}); const Project = sequelize.define('Project', {}, { hooks: { beforeCreate() { // 做点其他事 } } }); await User.create({}); // 运行全局 hook await Project.create({}); // 运行自己的 hook, 其次是全局 hook 也可以在传递给 Sequelize 构造函数的参数中定义常驻 hook： new Sequelize(..., { hooks: { beforeCreate() { // 做点什么 } } }); 请注意,以上内容与上述 默认 Hooks 不同. 那就是使用构造函数的 define 参数. 这里不是. 连接 Hooks Sequelize 提供了四个 hook,它们在获得或释放数据库连接之前和之后立即执行： sequelize.beforeConnect(callback) 回调具有以下形式 async (config) => /* ... */ sequelize.afterConnect(callback) 回调具有以下形式 async (connection, config) => /* ... */ sequelize.beforeDisconnect(callback) 回调具有以下形式 async (connection) => /* ... */ sequelize.afterDisconnect(callback) 回调具有以下形式 async (connection) => /* ... */ 如果你需要异步获取数据库凭据,或者需要在创建低级数据库连接后直接访问它,这些 hook 很有用. 例如,我们可以从令牌存储异步获取数据库密码,并使用新的凭证对 Sequelize 的配置对象进行更新： sequelize.beforeConnect(async (config) => { config.password = await getAuthToken(); }); 这些 hook 只能 被 声明为永久全局 hook,因为所有模型都共享连接池. 实例 hooks 每当你编辑单个对象时,都会触发以下 hook： beforeValidate afterValidate / validationFailed beforeCreate / beforeUpdate / beforeSave / beforeDestroy afterCreate / afterUpdate / afterSave / afterDestroy User.beforeCreate(user => { if (user.accessLevel > 10 && user.username !== \"Boss\") { throw new Error(\"You can't grant this user an access level above 10!\"); } }); 以下示例将引发错误: try { await User.create({ username: 'Not a Boss', accessLevel: 20 }); } catch (error) { console.log(error); // 你不能授予该用户10以上的访问权限！ }; 以下示例将成功: const user = await User.create({ username: 'Boss', accessLevel: 20 }); console.log(user); // 用户对象,用户名 `Boss`,accessLevel 为 20 模型 hooks 有时你会使用诸如 bulkCreate, update 和 destroy 之类的方法一次编辑多个记录. 每当你使用这些方法之一时,就会触发以下 hook： YourModel.beforeBulkCreate(callback) 回调具有以下形式 (instances, options) => /* ... */ YourModel.beforeBulkUpdate(callback) 回调具有以下形式 (options) => /* ... */ YourModel.beforeBulkDestroy(callback) 回调具有以下形式 (options) => /* ... */ YourModel.afterBulkCreate(callback) 回调具有以下形式 (instances, options) => /* ... */ YourModel.afterBulkUpdate(callback) 回调具有以下形式 (options) => /* ... */ YourModel.afterBulkDestroy(callback) 回调具有以下形式 (options) => /* ... */ 注意：默认情况下,类似 bulkCreate 的方法不会触发单独的 hook - 仅批量 hook. 但是,如果你还希望触发单个 hook,则可以将 { individualHooks: true } 参数传递给查询调用. 但是,这可能会严重影响性能,具体取决于所涉及的记录数(因为,除其他外,所有实例都将被加载到内存中). 例子： await Model.destroy({ where: { accessLevel: 0 }, individualHooks: true }); // 这将选择所有将要删除的记录,并在每个实例上触发 `beforeDestroy` 和 `afterDestroy`. await Model.update({ username: 'Tony' }, { where: { accessLevel: 0 }, individualHooks: true }); // 这将选择所有将要更新的记录,并在每个实例上发出 `beforeUpdate` 和 `afterUpdate`. 如果你将 Model.bulkCreate(...) 与 updateOnDuplicate 参数一起使用,则对 hook 中对 updateOnDuplicate 数组中未提供的字段所做的更改将不会保留到数据库中. 但是,如果需要的话,可以在挂钩中更改 updateOnDuplicate 参数. User.beforeBulkCreate((users, options) => { for (const user of users) { if (user.isMember) { user.memberSince = new Date(); } } // 将 `memberSince` 添加到 updateOnDuplicate,否则它将不会持久化 if (options.updateOnDuplicate && !options.updateOnDuplicate.includes('memberSince')) { options.updateOnDuplicate.push('memberSince'); } }); // 使用 updateOnDuplicate 参数批量更新现有用户 await Users.bulkCreate([ { id: 1, isMember: true }, { id: 2, isMember: false } ], { updateOnDuplicate: ['isMember'] }); 关联 在大多数情况下,hook 在关联时对实例的作用相同. 一对一和一对多关联 当使用 add/set mixin 方法时,beforeUpdate 和 afterUpdate hook 将运行. beforeDestroy 和 afterDestroy hook 只会在具有 onDelete: 'CASCADE' 和 hooks: true 的关联上被调用. 例如 class Projects extends Model {} Projects.init({ title: DataTypes.STRING }, { sequelize }); class Tasks extends Model {} Tasks.init({ title: DataTypes.STRING }, { sequelize }); Projects.hasMany(Tasks, { onDelete: 'CASCADE', hooks: true }); Tasks.belongsTo(Projects); 该代码将在 Tasks 模型上运行 beforeDestroy 和 afterDestroy hook. 默认情况下,Sequelize 将尝试尽可能优化你的查询. 当在删除时调用级联时,Sequelize 将简单地执行： DELETE FROM `table` WHERE associatedIdentifier = associatedIdentifier.primaryKey 但是,添加 hooks: true 会明确告诉 Sequelize 优化与你无关. 然后,Sequelize 首先将对关联的对象执行 SELECT 并逐个销毁每个实例,以便能够正确调用 hook(使用正确的参数). 多对多关联 当对 belongsToMany 关系使用 add mixin 方法时(将一个或多个记录添加到联结表中),联结模型中的 beforeBulkCreate 和 afterBulkCreate hook 将运行. 如果将 { individualHooks: true } 传递给该调用,则每个单独的 hook 也将运行. 当对 belongsToMany 关系使用 remove mixin 方法时(将一个或多个记录删除到联结表中),联结模型中的 beforeBulkDestroy 和 afterBulkDestroy hook 将运行. 如果将 { individualHooks: true } 传递给该调用,则每个单独的 hook 也将运行. 如果你的关联是多对多,则在使用 remove 调用时,你可能会对在直通模型上触发 hook 感兴趣. 在内部,sequelize 使用的是 Model.destroy,从而导致在每个直通实例上调用 bulkDestroy 而不是 before/afterDestroy hook. Hooks 和 事务 Sequelize 中的许多模型操作都允许你在方法的 options 参数中指定事务. 如果在原始调用中指定了事务,则该事务将出现在传递给 hook 函数的 options 参数中. 例如,考虑以下代码片段： User.addHook('afterCreate', async (user, options) => { // 我们可以使用 `options.transaction` 来执行 // 与触发此 hook 的调用相同的事务来执行其他一些调用 await User.update({ mood: 'sad' }, { where: { id: user.id }, transaction: options.transaction }); }); await sequelize.transaction(async t => { await User.create({ username: 'someguy', mood: 'happy' }, { transaction: t }); }); 如果在前面的代码中对 User.update 的调用中未包含 transaction 参数,则不会发生更改,因为在提交未决事务之前,数据库中不存在我们新创建的用户. 内部事务 重要的是要认识到,sequelize 可能会在内部对某些操作(例如Model.findOrCreate)使用事务. 如果 hook 函数执行依赖于数据库中对象存在的读取或写入操作,或者像上一节中的示例一样修改对象的存储值,则应始终指定{transaction：options.transaction}： 如果使用了事务,则 {transaction：options.transaction} 将确保再次使用该事务; 否则,{ transaction: options.transaction } 等同于 { transaction: undefined },这将不使用事务. 这样,你的 hook 将始终正确运行. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/query-interface.html":{"url":"other-topics/query-interface.html","title":"Query Interface - 查询接口","keywords":"","body":"Query Interface - 查询接口 Sequelize 实例使用一种称为 查询接口 的东西来以与方言无关的方式与数据库进行通信. 你在本手册中学到的大多数方法都是通过查询接口中的几种方法来实现的. 因此,查询接口中的方法是较低级的方法; 仅当找不到其他方法来使用 Sequelize 的高级 API 时,才应使用它们. 当然,它们比直接运行原始查询(即,手工编写SQL)的级别更高. 本指南展示了一些示例,但是要获取其功能的完整列表以及每种方法的详细用法,请查看查询接口 API. 获取查询界面 从现在开始,我们将 queryInterface 称为 查询接口 类的单例实例,该实例可在你的 Sequelize 实例上使用： const { Sequelize, DataTypes } = require('sequelize'); const sequelize = new Sequelize(/* ... */); const queryInterface = sequelize.getQueryInterface(); 创建一个表 queryInterface.createTable('Person', { name: DataTypes.STRING, isBetaMember: { type: DataTypes.BOOLEAN, defaultValue: false, allowNull: false } }); 生成 SQL (使用 SQLite): CREATE TABLE IF NOT EXISTS `Person` ( `name` VARCHAR(255), `isBetaMember` TINYINT(1) NOT NULL DEFAULT 0 ); 注意: 考虑定义一个模型,然后调用 YourModel.sync(),这是一个较高级别的方法. 向表添加列 queryInterface.addColumn('Person', 'petName', { type: DataTypes.STRING }); 生成 SQL (使用 SQLite): ALTER TABLE `Person` ADD `petName` VARCHAR(255); 更改列的数据类型 queryInterface.changeColumn('Person', 'foo', { type: DataTypes.FLOAT, defaultValue: 3.14, allowNull: false }); 生成 SQL (使用 MySQL): ALTER TABLE `Person` CHANGE `foo` `foo` FLOAT NOT NULL DEFAULT 3.14; 删除列 queryInterface.removeColumn('Person', 'petName', { /* 查询参数 */ }); 生成 SQL (使用 PostgreSQL): ALTER TABLE \"public\".\"Person\" DROP COLUMN \"petName\"; 更改和删除 SQLite 中的列 SQLite 不支持直接更改和删除列. 但是,Sequelize 将通过受这些说明的启发在备份表的帮助下重新创建整个表,以解决此问题. 示例: // 假设我们在 SQLite 中创建了一个表,如下所示: queryInterface.createTable('Person', { name: DataTypes.STRING, isBetaMember: { type: DataTypes.BOOLEAN, defaultValue: false, allowNull: false }, petName: DataTypes.STRING, foo: DataTypes.INTEGER }); // 我们改变一列: queryInterface.changeColumn('Person', 'foo', { type: DataTypes.FLOAT, defaultValue: 3.14, allowNull: false }); 为 SQLite 生成了以下 SQL 调用: PRAGMA TABLE_INFO(`Person`); CREATE TABLE IF NOT EXISTS `Person_backup` ( `name` VARCHAR(255), `isBetaMember` TINYINT(1) NOT NULL DEFAULT 0, `foo` FLOAT NOT NULL DEFAULT '3.14', `petName` VARCHAR(255) ); INSERT INTO `Person_backup` SELECT `name`, `isBetaMember`, `foo`, `petName` FROM `Person`; DROP TABLE `Person`; CREATE TABLE IF NOT EXISTS `Person` ( `name` VARCHAR(255), `isBetaMember` TINYINT(1) NOT NULL DEFAULT 0, `foo` FLOAT NOT NULL DEFAULT '3.14', `petName` VARCHAR(255) ); INSERT INTO `Person` SELECT `name`, `isBetaMember`, `foo`, `petName` FROM `Person_backup`; DROP TABLE `Person_backup`; 其它 如本指南开头所述,Sequelize 中的查询接口还有很多！ 查看 查询接口 API,以获取可以完成的操作的完整列表. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/naming-strategies.html":{"url":"other-topics/naming-strategies.html","title":"Naming Strategies - 命名策略","keywords":"","body":"Naming Strategies - 命名策略 underscored 参数 Sequelize 为模型提供了 underscored 参数. 设为 true 时,此参数会将所有属性的 field 参数设置为其名称的 snake_case 版本. 这也适用于由关联和其他自动生成的字段自动生成的外键. 例： const User = sequelize.define('user', { username: Sequelize.STRING }, { underscored: true }); const Task = sequelize.define('task', { title: Sequelize.STRING }, { underscored: true }); User.hasMany(Task); Task.belongsTo(User); 上面我们有模型 User 和 Task,都使用了 underscored 的参数. 他们之间也有一对多的关系. 另外,回想一下,由于默认情况下 timestamps 为 true,因此我们应该期望 createedAt 和 updatedAt 字段也将自动创建. 如果没有 underscored 参数,Sequelize 会自动定义： 每个模型的 createdAt 属性,指向每个表中名为 createdAt 的列 每个模型的 updatedAt 属性,指向每个表中名为 updatedAt 的列 Task 模型中的 userId 属性,指向任务表中名为 userId 的列 启用 underscored 参数后,Sequelize 将改为定义： 每个模型的 createdAt 属性,指向每个表中名为 created_at 的列 每个模型的 updatedAt 属性,指向每个表中名为 updated_at 的列 Task 模型中的 userId 属性,指向任务表中名为 user_id 的列 请注意,在这两种情况下,JavaScript 字段均仍为 camelCase; 此参数仅更改这些字段如何映射到数据库本身. 每个属性的 field 参数都设置为它们的 snake_case 版本,但属性本身仍为 camelCase. 这样,在上面的代码上调用 sync() 将会生成以下内容： CREATE TABLE IF NOT EXISTS \"users\" ( \"id\" SERIAL, \"username\" VARCHAR(255), \"created_at\" TIMESTAMP WITH TIME ZONE NOT NULL, \"updated_at\" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY (\"id\") ); CREATE TABLE IF NOT EXISTS \"tasks\" ( \"id\" SERIAL, \"title\" VARCHAR(255), \"created_at\" TIMESTAMP WITH TIME ZONE NOT NULL, \"updated_at\" TIMESTAMP WITH TIME ZONE NOT NULL, \"user_id\" INTEGER REFERENCES \"users\" (\"id\") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY (\"id\") ); 单数与复数 乍看之下,在 Sequelize 中是否应使用名称的单数形式或复数形式可能会造成混淆. 本节旨在澄清这一点. 回想一下 Sequelize 在后台使用了一个名为 inflection 的库,以便正确计算不规则的复数形式(例如 person -> people). 但是,如果你使用的是另一种语言,则可能需要直接定义名称的单数和复数形式. sequelize 允许你通过一些参数来执行此操作. 定义模型时 模型应以单词的单数形式定义. 例： sequelize.define('foo', { name: DataTypes.STRING }); 上面的模型名称是 foo(单数),表名称是 foos,因为 Sequelize 会自动获取表名称的复数形式. 在模型中定义参考键时 sequelize.define('foo', { name: DataTypes.STRING, barId: { type: DataTypes.INTEGER, allowNull: false, references: { model: \"bars\", key: \"id\" }, onDelete: \"CASCADE\" }, }); 在上面的示例中,我们手动定义了引用另一个模型的键. 这不是通常的做法,但是如果必须这样做,则应在此使用表名. 这是因为引用是根据引用的表名创建的. 在上面的示例中,使用了复数形式(bars),假设 bar 模型是使用默认设置创建的(使其基础表自动复数). 从预先加载中检索数据时 当你在查询中执行 include 时,包含的数据将根据以下规则添加到返回对象的额外字段中： 当包含来自单个关联(hasOne 或 belongsTo)的内容时,字段名称将是模型名称的单数形式; 当包含来自多个关联(hasMany 或 belongsToMany)的内容时,字段名称将是模型的复数形式. 简而言之,在每种情况下,字段名称将采用最合乎逻辑的形式. 示例: // 假设 Foo.hasMany(Bar) const foo = Foo.findOne({ include: Bar }); // foo.bars 将是一个数组 // foo.bar 将不存在,因为它没有意义 // 假设 Foo.hasOne(Bar) const foo = Foo.findOne({ include: Bar }); // foo.bar 将是一个对象(如果没有关联的模型,则可能为 null) // foo.bars 将不存在,因为它没有意义 // 等等. 定义别名时覆盖单数和复数 在为关联定义别名时,你可以传递一个对象以指定单数和复数形式,而不仅仅是使用 { as: 'myAlias' }. Project.belongsToMany(User, { as: { singular: 'líder', plural: 'líderes' } }); 如果你知道模型在关联中将始终使用相同的别名,则可以将单数和复数形式直接提供给模型本身： const User = sequelize.define('user', { /* ... */ }, { name: { singular: 'líder', plural: 'líderes', } }); Project.belongsToMany(User); 添加到用户实例的混入文件将使用正确的形式. 例如,Sequelize 将代替 project.addUser() 来提供 project.getLíder(). 另外,Sequelize 将代替 project.setUsers() 来提供 project.setLíderes(). 注意：记得使用 as 来改变关联的名字也会改变外键的名字. 因此,建议也指定在这种情况下直接涉及的外键. // 错误示例 Invoice.belongsTo(Subscription, { as: 'TheSubscription' }); Subscription.hasMany(Invoice); 上面的第一个调用将在 Invoice 上建立一个名为 theSubscriptionId 的外键. 但是,第二个调用也会在 Invoice 上建立外键(因为众所周知, hasMany 调用会将外键放置在目标模型中)-但是,它将被命名为 subscriptionId. 这样,你将同时具有 subscriptionId 和 theSubscriptionId 列. 最好的方法是为外键选择一个名称,并将其显式放置在两个调用中. 例如,如果选择了 subscription_id： // 修正示例 Invoice.belongsTo(Subscription, { as: 'TheSubscription', foreignKey: 'subscription_id' }); Subscription.hasMany(Invoice, { foreignKey: 'subscription_id' }); 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/scopes.html":{"url":"other-topics/scopes.html","title":"Scopes - 作用域","keywords":"","body":"Scopes - 作用域 作用域用于帮助你重用代码. 你可以定义常用查询,并指定诸如 where, include, limit 等参数. 本指南涉及模型作用域. 你可能也对关联作用域指南感兴趣,它们相似但又不同. 定义 作用域在模型定义中定义,可以是查找器对象,也可以是返回查找器对象的函数 - 默认作用域除外,该作用域只能是一个对象： class Project extends Model {} Project.init({ // 属性 }, { defaultScope: { where: { active: true } }, scopes: { deleted: { where: { deleted: true } }, activeUsers: { include: [ { model: User, where: { active: true } } ] }, random() { return { where: { someNumber: Math.random() } } }, accessLevel(value) { return { where: { accessLevel: { [Op.gte]: value } } } }, sequelize, modelName: 'project' } }); 你也可以在定义模型后通过调用 YourModel.addScope 添加作用域. 这对于具有包含的作用域特别有用,其中在定义另一个模型时可能未定义包含中的模型. 始终应用默认作用域. 这意味着,使用上面的模型定义,Project.findAll() 将创建以下查询： SELECT * FROM projects WHERE active = true 可以通过调用 .unscoped(), .scope(null), 或调用另一个作用域来删除默认作用域： await Project.scope('deleted').findAll(); // 删除默认作用域 SELECT * FROM projects WHERE deleted = true 也可以在作用域定义中包括作用域模型. 这样可以避免重复 include, attributes 或 where 定义. 使用上面的示例,并在包含的用户模型上调用 active 作用域(而不是直接在该包含对象中指定条件)： // 上例中定义的 `activeUsers` 作用域也可以通过以下方式定义： Project.addScope('activeUsers', { include: [ { model: User.scope('active') } ] }); 使用 通过在模型定义上调用 .scope,并传递一个或多个作用域的名称来应用作用域..scope 返回具有所有常规方法的功能齐全的模型实例：.findAll, .update, .count, .destroy 等.你可以保存此模型实例并在以后重用： const DeletedProjects = Project.scope('deleted'); await DeletedProjects.findAll(); // 以上相当于: await Project.findAll({ where: { deleted: true } }); 作用域适用于 .find, .findAll, .count, .update, .increment 和 .destroy. 作用域可以通过两种方式调用. 如果作用域不带任何参数,则可以正常调用它. 如果作用域接受参数,则传递一个对象： await Project.scope('random', { method: ['accessLevel', 19] }).findAll(); 生成 SQL: SELECT * FROM projects WHERE someNumber = 42 AND accessLevel >= 19 合并 通过将作用域数组传递给 .scope 或将作用域作为连续参数传递,可以同时应用多个作用域. // 这两个是等效的 await Project.scope('deleted', 'activeUsers').findAll(); await Project.scope(['deleted', 'activeUsers']).findAll(); 生成 SQL: SELECT * FROM projects INNER JOIN users ON projects.userId = users.id WHERE projects.deleted = true AND users.active = true 如果要在默认作用域之外应用另一个作用域,请将关键字 defaultScope 传递给.scope： await Project.scope('defaultScope', 'deleted').findAll(); 生成 SQL: SELECT * FROM projects WHERE active = true AND deleted = true 调用多个合并作用域时,后续合并作用域中的键将覆盖先前合并作用域中的键(类似于 Object.assign),除了将合并的 where 和 include 之外. 考虑两个作用域： YourMode.addScope('scope1', { where: { firstName: 'bob', age: { [Op.gt]: 20 } }, limit: 2 }); YourMode.addScope('scope2', { where: { age: { [Op.gt]: 30 } }, limit: 10 }); 使用 .scope('scope1', 'scope2') 将产生以下 WHERE 子句： WHERE firstName = 'bob' AND age > 30 LIMIT 10 注意 limit 和 age 如何被 scope2 覆盖,而保留 firstName.limit, offset, order, paranoid, lock 和 raw 字段被覆盖,而 where 则被浅合并(这意味着相同的键将被覆盖).包含的合并策略将在后面讨论. 注意,多个应用作用域的 attributes 键以始终保留 attributes.exclude 的方式合并. 这允许合并多个合并作用域,并且永远不会泄漏最终合并作用域中的敏感字段. 当将查找对象直接传递给作用域模型上的 findAll(和类似的查找器)时,适用相同的合并逻辑： Project.scope('deleted').findAll({ where: { firstName: 'john' } }) 生成的 where 子句： WHERE deleted = true AND firstName = 'john' 在这里, deleted 作用域与查找器合并. 如果我们将 where: { firstName: 'john', deleted: false } 传递给查找器,则 deleted 作用域将被覆盖. 合并 Include Include 将基于所包含的模型进行递归合并. 这是 v5 上添加的功能非常强大的合并,并通过示例更好地理解. 考虑模型 Foo, Bar, Baz 和 Qux,它们具有一对多关联,如下所示： const Foo = sequelize.define('Foo', { name: Sequelize.STRING }); const Bar = sequelize.define('Bar', { name: Sequelize.STRING }); const Baz = sequelize.define('Baz', { name: Sequelize.STRING }); const Qux = sequelize.define('Qux', { name: Sequelize.STRING }); Foo.hasMany(Bar, { foreignKey: 'fooId' }); Bar.hasMany(Baz, { foreignKey: 'barId' }); Baz.hasMany(Qux, { foreignKey: 'bazId' }); 现在,考虑在 Foo 上定义的以下四个作用域: Foo.addScope('includeEverything', { include: { model: Bar, include: [{ model: Baz, include: Qux }] } }); Foo.addScope('limitedBars', { include: [{ model: Bar, limit: 2 }] }); Foo.addScope('limitedBazs', { include: [{ model: Bar, include: [{ model: Baz, limit: 2 }] }] }); Foo.addScope('excludeBazName', { include: [{ model: Bar, include: [{ model: Baz, attributes: { exclude: ['name'] } }] }] }); 这四个作用域可以很容易地进行深度合并,例如,通过调用 Foo.scope('includeEverything', 'limitedBars', 'limitedBazs', 'excludeBazName').findAll(),这完全等同于调用以下代码： await Foo.findAll({ include: { model: Bar, limit: 2, include: [{ model: Baz, limit: 2, attributes: { exclude: ['name'] }, include: Qux }] } }); // 以上等同于： await Foo.scope([ 'includeEverything', 'limitedBars', 'limitedBazs', 'excludeBazName' ]).findAll(); 观察如何将四个作用域合并为一个. 作用域的 include 根据所包含的模型进行合并. 如果一个作用域包含模型 A,另一个作用域包含模型 B,则合并结果将同时包含模型 A 和 B.另一方面,如果两个作用域都包含相同的模型 A,但具有不同的参数(例如嵌套包含或其他属性) ,这些将被递归合并,如上所示. 上面说明的合并以完全相同的方式工作,而不管应用于作用域的顺序如何. 如果某个选项由两个不同的作用域设置,则顺序只会有所不同 - 上面的示例不是这种情况,因为每个作用域执行的操作都不相同. 这种合并策略还可以与传递给 .findAll, .findOne 等的参数完全相同. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/sub-queries.html":{"url":"other-topics/sub-queries.html","title":"Sub Queries - 子查询","keywords":"","body":"Sub Queries - 子查询 考虑你有两个模型,即 Post 和 Reaction,它们之间建立了一对多的关系,因此一个 post 有很多 reactions： const Post = sequelize.define('post', { content: DataTypes.STRING }, { timestamps: false }); const Reaction = sequelize.define('reaction', { type: DataTypes.STRING }, { timestamps: false }); Post.hasMany(Reaction); Reaction.belongsTo(Post); 注意: 我们已禁用时间戳,只是为了缩短下一个示例的查询时间. 让我们用一些数据填充表格: async function makePostWithReactions(content, reactionTypes) { const post = await Post.create({ content }); await Reaction.bulkCreate( reactionTypes.map(type => ({ type, postId: post.id })) ); return post; } await makePostWithReactions('Hello World', [ 'Like', 'Angry', 'Laugh', 'Like', 'Like', 'Angry', 'Sad', 'Like' ]); await makePostWithReactions('My Second Post', [ 'Laugh', 'Laugh', 'Like', 'Laugh' ]); 现在,我们已经准备好子查询功能的示例. 假设我们要通过 SQL 为每个帖子计算一个 laughReactionsCount. 我们可以通过子查询来实现,例如： SELECT *, ( SELECT COUNT(*) FROM reactions AS reaction WHERE reaction.postId = post.id AND reaction.type = \"Laugh\" ) AS laughReactionsCount FROM posts AS post 如果我们通过 Sequelize 运行上面的原始 SQL 查询,我们将得到: [ { \"id\": 1, \"content\": \"Hello World\", \"laughReactionsCount\": 1 }, { \"id\": 2, \"content\": \"My Second Post\", \"laughReactionsCount\": 3 } ] 那么,如何在 Sequelize 的帮助下实现这一目标,而不必手工编写整个原始查询呢？ 答案是: 通过将 finder 方法(例如,findAll)的 attributes 参数与 sequelize.literal 实用程序功能结合使用,可以直接在查询中插入任意内容,而不会自动转义. 这意味着 Sequelize 将帮助你进行较大的主要查询,但是你仍然必须自己编写该子查询： Post.findAll({ attributes: { include: [ [ // 注意下面的调用中的括号！ sequelize.literal(`( SELECT COUNT(*) FROM reactions AS reaction WHERE reaction.postId = post.id AND reaction.type = \"Laugh\" )`), 'laughReactionsCount' ] ] } }); 重要提示：由于 sequelize.literal 会插入任意内容而不进行转义,因此,它可能是(主要)安全漏洞的来源,因此值得特别注意. 它不应该在用户生成的内容上使用.但是在这里,我们使用自己编写的带有固定字符串的 sequelize.literal.因为我们知道我们在做什么. 上面给出了以下输出: [ { \"id\": 1, \"content\": \"Hello World\", \"laughReactionsCount\": 1 }, { \"id\": 2, \"content\": \"My Second Post\", \"laughReactionsCount\": 3 } ] 成功! 使用子查询进行复杂排序 这个想法可用于实现复杂的排序,例如根据 post 具有的 laugh 数量来排序帖子： Post.findAll({ attributes: { include: [ [ sequelize.literal(`( SELECT COUNT(*) FROM reactions AS reaction WHERE reaction.postId = post.id AND reaction.type = \"Laugh\" )`), 'laughReactionsCount' ] ] }, order: [ [sequelize.literal('laughReactionsCount'), 'DESC'] ] }); 结果: [ { \"id\": 2, \"content\": \"My Second Post\", \"laughReactionsCount\": 3 }, { \"id\": 1, \"content\": \"Hello World\", \"laughReactionsCount\": 1 } ] 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/other-data-types.html":{"url":"other-topics/other-data-types.html","title":"Other Data Types - 其他数据类型","keywords":"","body":"Other Data Types - 其他数据类型 除了模型基础指南中提到的最常见的数据类型外,Sequelize 还提供了其他几种数据类型. 范围 (仅限 PostgreSQL) DataTypes.RANGE(DataTypes.INTEGER) // int4range DataTypes.RANGE(DataTypes.BIGINT) // int8range DataTypes.RANGE(DataTypes.DATE) // tstzrange DataTypes.RANGE(DataTypes.DATEONLY) // daterange DataTypes.RANGE(DataTypes.DECIMAL) // numrange 由于范围类型对于它们绑定的 包含/排除 具有额外的信息,因此仅使用元组在 javascript 中表示它们并不是很容易. 当提供范围值时,可以从以下 API 中进行选择： // 默认为包含下限,排除上限 const range = [ new Date(Date.UTC(2016, 0, 1)), new Date(Date.UTC(2016, 1, 1)) ]; // '[\"2016-01-01 00:00:00+00:00\", \"2016-02-01 00:00:00+00:00\")' // 控制包含 const range = [ { value: new Date(Date.UTC(2016, 0, 1)), inclusive: false }, { value: new Date(Date.UTC(2016, 1, 1)), inclusive: true }, ]; // '(\"2016-01-01 00:00:00+00:00\", \"2016-02-01 00:00:00+00:00\"]' // 复合形式 const range = [ { value: new Date(Date.UTC(2016, 0, 1)), inclusive: false }, new Date(Date.UTC(2016, 1, 1)), ]; // '(\"2016-01-01 00:00:00+00:00\", \"2016-02-01 00:00:00+00:00\")' const Timeline = sequelize.define('Timeline', { range: DataTypes.RANGE(DataTypes.DATE) }); await Timeline.create({ range }); 然而,检索到的范围值始终以对象数组的形式出现. 例如,如果在 finder 查询后,存储的值是 (\"2016-01-01 00:00:00+00:00\", \"2016-02-01 00:00:00+00:00\"] 你会得到： [ { value: Date, inclusive: false }, { value: Date, inclusive: true } ] 使用范围类型更新实例后,你需要调用 reload() 或使用 returning: true 参数. 特别案例 // 空范围: Timeline.create({ range: [] }); // range = 'empty' // 无界范围: Timeline.create({ range: [null, null] }); // range = '[,)' // range = '[,\"2016-01-01 00:00:00+00:00\")' Timeline.create({ range: [null, new Date(Date.UTC(2016, 0, 1))] }); // 无限范围: // range = '[-infinity,\"2016-01-01 00:00:00+00:00\")' Timeline.create({ range: [-Infinity, new Date(Date.UTC(2016, 0, 1))] }); BLOB DataTypes.BLOB // BLOB (PostgreSQL 的 bytea) DataTypes.BLOB('tiny') // TINYBLOB (PostgreSQL 的 bytea) DataTypes.BLOB('medium') // MEDIUMBLOB (PostgreSQL 的 bytea) DataTypes.BLOB('long') // LONGBLOB (PostgreSQL 的 bytea) Blob 数据类型允许你将数据既作为字符串又作为缓冲区插入. 但是,当使用 Sequelize从 数据库中检索 Blob 时,将始终将其作为缓冲区检索. ENUM ENUM 是仅接受几个值(指定为列表)的数据类型. DataTypes.ENUM('foo', 'bar') // 允许值为'foo'和'bar'的ENUM 也可以使用列定义的 values 字段指定 ENUM,如下所示： sequelize.define('foo', { states: { type: DataTypes.ENUM, values: ['active', 'pending', 'deleted'] } }); JSON (仅限 SQLite, MySQL, MariaDB 和 PostgreSQL) 仅 SQLite,MySQL,MariaDB 和 PostgreSQL 支持 DataTypes.JSON 数据类型. 但是,对 MSSQL 的支持最少(请参见下文). PostgreSQL 的注意事项 PostgreSQL 中的 JSON 数据类型将值存储为纯文本,而不是二进制表示. 如果只想存储和检索 JSON 表示形式,则使用 JSON 将占用更少的磁盘空间,并需要更少的时间从其输入表示形式进行构建. 但是,如果要对 JSON 值执行任何操作,则应首选以下所述的 JSONB 数据类型. JSONB (仅限 PostgreSQL) PostgreSQL 还支持 JSONB 数据类型： DataTypes.JSONB. 可以通过三种不同的方式查询它： // 嵌套对象 await Foo.findOne({ where: { meta: { video: { url: { [Op.ne]: null } } } } }); // 嵌套键 await Foo.findOne({ where: { \"meta.audio.length\": { [Op.gt]: 20 } } }); // 包含限制 await Foo.findOne({ where: { meta: { [Op.contains]: { site: { url: 'http://google.com' } } } } }); MSSQL MSSQL 没有 JSON 数据类型,但是自 SQL Server 2016 起,它确实通过某些函数提供了对以字符串形式存储的 JSON 的支持.使用这些函数,你将能够查询存储在字符串中的 JSON,但是所有返回的值将需要单独解析. // ISJSON - 测试字符串是否包含有效的 JSON await User.findAll({ where: sequelize.where(sequelize.fn('ISJSON', sequelize.col('userDetails')), 1) }) // JSON_VALUE - 从 JSON 字符串中提取标量值 await User.findAll({ attributes: [[ sequelize.fn('JSON_VALUE', sequelize.col('userDetails'), '$.address.Line1'), 'address line 1']] }) // JSON_VALUE - 从 JSON 字符串查询标量值 await User.findAll({ where: sequelize.where(sequelize.fn('JSON_VALUE', sequelize.col('userDetails'), '$.address.Line1'), '14, Foo Street') }) // JSON_QUERY - 提取对象或数组 await User.findAll({ attributes: [[ sequelize.fn('JSON_QUERY', sequelize.col('userDetails'), '$.address'), 'full address']] }) 其他 DataTypes.ARRAY(/* DataTypes.SOMETHING */) // 定义一个 DataTypes.SOMETHING 数组. 仅限 PostgreSQL. DataTypes.CIDR // CIDR 仅限 PostgreSQL DataTypes.INET // INET 仅限 PostgreSQL DataTypes.MACADDR // MACADDR 仅限 PostgreSQL DataTypes.GEOMETRY // 空间列. 仅限 PostgreSQL (使用 PostGIS) 或 MySQL. DataTypes.GEOMETRY('POINT') // 具有几何类型的空间列.仅限 PostgreSQL (使用 PostGIS) 或 MySQL. DataTypes.GEOMETRY('POINT', 4326) // 具有几何类型和 SRID 的空间列.仅限 PostgreSQL (使用 PostGIS) 或 MySQL. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/constraints-and-circularities.html":{"url":"other-topics/constraints-and-circularities.html","title":"Constraints & Circularities - 约束 & 循环","keywords":"","body":"Constraints & Circularities - 约束 & 循环 在表之间添加约束意味着使用 sequelize.sync 时必须在数据库中以一定顺序创建表. 如果 Task 具有对 User 的引用,则必须先创建 User 表,然后才能创建 Task 表. 有时这可能会导致循环引用,而 Sequelize 无法找到同步的顺序. 想象一下文档和版本的情况. 一个文档可以有多个版本,为方便起见,文档引用了其当前版本. const { Sequelize, Model, DataTypes } = require(\"sequelize\"); class Document extends Model {} Document.init({ author: DataTypes.STRING }, { sequelize, modelName: 'document' }); class Version extends Model {} Version.init({ timestamp: DataTypes.DATE }, { sequelize, modelName: 'version' }); Document.hasMany(Version); // 这会将 documentId 属性添加到 version 中 Document.belongsTo(Version, { as: 'Current', foreignKey: 'currentVersionId' }); // 这会将 currentVersionId 属性添加到 document 中 但是,不幸的是,上面的代码将导致以下错误: Cyclic dependency found. documents is dependent of itself. Dependency chain: documents -> versions => documents 为了减少这种情况,我们可以将 constraints: false 传递给关联之一: Document.hasMany(Version); Document.belongsTo(Version, { as: 'Current', foreignKey: 'currentVersionId', constraints: false }); 这将使我们能够正确同步表: CREATE TABLE IF NOT EXISTS \"documents\" ( \"id\" SERIAL, \"author\" VARCHAR(255), \"createdAt\" TIMESTAMP WITH TIME ZONE NOT NULL, \"updatedAt\" TIMESTAMP WITH TIME ZONE NOT NULL, \"currentVersionId\" INTEGER, PRIMARY KEY (\"id\") ); CREATE TABLE IF NOT EXISTS \"versions\" ( \"id\" SERIAL, \"timestamp\" TIMESTAMP WITH TIME ZONE, \"createdAt\" TIMESTAMP WITH TIME ZONE NOT NULL, \"updatedAt\" TIMESTAMP WITH TIME ZONE NOT NULL, \"documentId\" INTEGER REFERENCES \"documents\" (\"id\") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY (\"id\") ); 不受限制地强制执行外键引用 有时,你可能希望引用另一个表,而不添加任何约束或关联. 在这种情况下,你可以将引用属性手动添加到架构定义中,并标记它们之间的关系. class Trainer extends Model {} Trainer.init({ firstName: Sequelize.STRING, lastName: Sequelize.STRING }, { sequelize, modelName: 'trainer' }); // 在我们调用 Trainer.hasMany(series) 之后, // Series 将会有一个 trainerId = Trainer.id 外参考键 class Series extends Model {} Series.init({ title: Sequelize.STRING, subTitle: Sequelize.STRING, description: Sequelize.TEXT, // 设置与 `Trainer` 的外键关系(hasMany) trainerId: { type: DataTypes.INTEGER, references: { model: Trainer, key: 'id' } } }, { sequelize, modelName: 'series' }); // 在我们调用 Series.hasOne(Video) 之后, // Video 将具有 seriesId = Series.id 外参考键 class Video extends Model {} Video.init({ title: Sequelize.STRING, sequence: Sequelize.INTEGER, description: Sequelize.TEXT, // 设置与 `Series` 的关系(hasOne) seriesId: { type: DataTypes.INTEGER, references: { model: Series, // 可以是代表表名的字符串,也可以是 Sequelize 模型 key: 'id' } } }, { sequelize, modelName: 'video' }); Series.hasOne(Video); Trainer.hasMany(Series); 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/extending-data-types.html":{"url":"other-topics/extending-data-types.html","title":"Extending Data Types - 扩展数据类型","keywords":"","body":"Extending Data Types - 扩展数据类型 你尝试实现的类型很可能已经包含在数据类型中. 如果不包括新的数据类型,本手册将说明如何自己编写它. Sequelize 不会在数据库中创建新的数据类型. 本教程说明了如何使 Sequelize 识别新数据类型,并假定这些新数据类型已在数据库中创建. 要扩展 Sequelize 数据类型,请在创建 Sequelize 实例之前进行. 示例 在此示例中,我们将创建一个名为 SOMETYPE 的类型,该类型将复制内置数据类型 DataTypes.INTEGER(11).ZEROFILL.UNSIGNED. const { Sequelize, DataTypes, Utils } = require('Sequelize'); createTheNewDataType(); const sequelize = new Sequelize('sqlite::memory:'); function createTheNewDataType() { class SOMETYPE extends DataTypes.ABSTRACT { // 强制性的: 在数据库中完整定义新类型 toSql() { return 'INTEGER(11) UNSIGNED ZEROFILL' } // 可选的: 验证器功能 validate(value, options) { return (typeof value === 'number') && (!Number.isNaN(value)); } // 可选的: sanitizer _sanitize(value) { // 强制所有数字为正 return value 创建此新数据类型后,你需要在每个数据库方言中映射此数据类型并进行一些调整. PostgreSQL 假设新数据类型的名称在 postgres 数据库中为 pg_new_type. 该名称必须映射到 DataTypes.SOMETYPE. 此外,还需要创建特定于 Postgres 的子数据类型. function createTheNewDataType() { // [...] const PgTypes = DataTypes.postgres; // 强制性的: 映射 postgres 数据类型名称 DataTypes.SOMETYPE.types.postgres = ['pg_new_type']; // 强制性的: 使用自己的解析方法创建特定于 postgres 的子数据类型. // 解析器将动态映射到 pg_new_type 的 OID. PgTypes.SOMETYPE = function SOMETYPE() { if (!(this instanceof PgTypes.SOMETYPE)) { return new PgTypes.SOMETYPE(); } DataTypes.SOMETYPE.apply(this, arguments); } const util = require('util'); // Node 包内置 util.inherits(PgTypes.SOMETYPE, DataTypes.SOMETYPE); // 强制性的: 创建,覆盖或重新分配特定于 Postgres 的解析器 // PgTypes.SOMETYPE.parse = value => value; PgTypes.SOMETYPE.parse = DataTypes.SOMETYPE.parse || x => x; // 可选的: 添加或覆盖特定于Postgres数据类型的方法, // 例如 toSql, escape, validate, _stringify, _sanitize... } 范围 在postgres中定义了新的范围类型后,将其添加到 Sequelize 变得很简单. 在此示例中,postgres 范围类型的名称为 SOMETYPE_range,基础 postgres 数据类型的名称为 pg_new_type. subtypes 和 castTypes 的键是 Sequelize 数据类型 DataTypes.SOMETYPE.key 的键(小写). function createTheNewDataType() { // [...] // 添加 postgresql 范围,SOMETYPE 来自 DataType.SOMETYPE.key(小写) DataTypes.RANGE.types.postgres.subtypes.SOMETYPE = 'SOMETYPE_range'; DataTypes.RANGE.types.postgres.castTypes.SOMETYPE = 'pg_new_type'; } 新范围可在模型定义中用作 DataTypes.RANGE(DataTypes.SOMETYPE) 或 DataTypes.RANGE(DataTypes.SOMETYPE). 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/indexes.html":{"url":"other-topics/indexes.html","title":"Indexes - 索引","keywords":"","body":"Indexes - 索引 Sequelize 支持在模型定义上添加索引,该索引将在 sequelize.sync() 上创建 const User = sequelize.define('User', { /* 属性 */ }, { indexes: [ // 在 email 上创建唯一索引 { unique: true, fields: ['email'] }, // 使用 jsonb_path_ops 运算符在 data 上创建 gin 索引 { fields: ['data'], using: 'gin', operator: 'jsonb_path_ops' }, // 默认情况下,索引名称将为 [table]_[fields] // 创建多列部分索引 { name: 'public_by_author', fields: ['author', 'status'], where: { status: 'public' } }, // 具有 order 字段的 BTREE 索引 { name: 'title_index', using: 'BTREE', fields: [ 'author', { name: 'title', collate: 'en_US', order: 'DESC', length: 5 } ] } ] }); 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/optimistic-locking.html":{"url":"other-topics/optimistic-locking.html","title":"Optimistic Locking - 乐观锁定","keywords":"","body":"Optimistic Locking - 乐观锁定 Sequelize 内置支持通过模型实例版本计数进行乐观锁定. 乐观锁定默认情况下处于禁用状态,可以通过在特定模型定义或全局模型配置中将 version 属性设置为 true 来启用. 有关更多详细信息,请参见模型基础. 乐观锁定允许并发访问模型记录以进行编辑,并防止冲突覆盖数据. 它通过检查自从读取以来另一个进程是否对记录进行了更改,并在检测到冲突时抛出 OptimisticLockError 来执行此操作. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/read-replication.html":{"url":"other-topics/read-replication.html","title":"Read Replication - 读取复制","keywords":"","body":"Read Replication - 读取复制 Sequelize 支持 读取复制, 即,当你要执行 SELECT 查询时,可以连接多个服务器. 当你执行读取复制时,你可以指定一台或多台服务器充当读取副本,并指定一台服务器充当写入主机,该主机处理所有写入和更新并将它们传播到副本(请注意,实际复制过程 不是 由 Sequelize 处理,而应由数据库后端设置). const sequelize = new Sequelize('database', null, null, { dialect: 'mysql', port: 3306, replication: { read: [ { host: '8.8.8.8', username: 'read-1-username', password: process.env.READ_DB_1_PW }, { host: '9.9.9.9', username: 'read-2-username', password: process.env.READ_DB_2_PW } ], write: { host: '1.1.1.1', username: 'write-username', password: process.env.WRITE_DB_PW } }, pool: { // 如果要覆盖用于 读/写 池的参数,可以在此处执行 max: 20, idle: 30000 }, }) 如果你有适用于所有副本的常规设置,则无需为每个实例提供它们. 在上面的代码中,数据库名称和端口将传播到所有副本. 如果将用户名和密码留给任何副本,则同样会生效. 每个副本具有以下参数：host, port, username, password, database. Sequelize 使用池来管理与副本的连接. 在内部,Sequelize 将维护使用 pool 配置创建的两个池. 如果要修改这些设置,可以在实例化 Sequelize 时将 pool 作为参数传递,如上所示. 每个 write 或 useMaster: true 查询都将使用写入池. 对于 SELECT,将使用读取池. 使用基本的循环调度来切换只读副本. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/connection-pool.html":{"url":"other-topics/connection-pool.html","title":"Connection Pool - 连接池","keywords":"","body":"Connection Pool - 连接池 如果要从单个进程连接到数据库,则应仅创建一个 Sequelize 实例. Sequelize 将在初始化时建立连接池. 可以通过构造函数的 options 参数(使用 options.pool)来配置此连接池,如以下示例所示： const sequelize = new Sequelize(/* ... */, { // ... pool: { max: 5, min: 0, acquire: 30000, idle: 10000 } }); 在 Sequelize 构造函数的 API 参考中了解更多信息. 如果要从多个进程连接到数据库,则必须为每个进程创建一个实例,但是每个实例的最大连接池大小应达到最大总大小. 例如,如果你希望最大连接池大小为90,并且有三个进程,则每个进程的 Sequelize 实例的最大连接池大小应为30. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/legacy.html":{"url":"other-topics/legacy.html","title":"Working with Legacy Tables - 使用遗留表","keywords":"","body":"Working with Legacy Tables - 使用遗留表 虽然 Sequelize 自认为可以开箱即用, 但是如果你要处理遗留表并向前验证应用程序,仅需要通过定义(否则生成)表和字段名称即可. 表 class User extends Model {} User.init({ // ... }, { modelName: 'user', tableName: 'users', sequelize, }); 字段 class MyModel extends Model {} MyModel.init({ userId: { type: DataTypes.INTEGER, field: 'user_id' } }, { sequelize }); 主键 默认情况下,Sequelize 会假设你的表具有 id 主键属性. 定义自己的主键: class Collection extends Model {} Collection.init({ uid: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true // 自动转换为 PostgreSQL 的 SERIAL } }, { sequelize }); class Collection extends Model {} Collection.init({ uuid: { type: DataTypes.UUID, primaryKey: true } }, { sequelize }); 如果你的模型根本没有主键,则可以使用 Model.removeAttribute('id'); 外键 // 1:1 Organization.belongsTo(User, { foreignKey: 'owner_id' }); User.hasOne(Organization, { foreignKey: 'owner_id' }); // 1:M Project.hasMany(Task, { foreignKey: 'tasks_pk' }); Task.belongsTo(Project, { foreignKey: 'tasks_pk' }); // N:M User.belongsToMany(Role, { through: 'user_has_roles', foreignKey: 'user_role_user_id' }); Role.belongsToMany(User, { through: 'user_has_roles', foreignKey: 'roles_identifier' }); 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/migrations.html":{"url":"other-topics/migrations.html","title":"Migrations - 迁移","keywords":"","body":"Migrations - 迁移 就像你使用版本控制 如 Git 来管理源代码的更改一样,你可以使用迁移来跟踪数据库的更改. 通过迁移,你可以将现有的数据库转移到另一个状态,反之亦然:这些状态转换将保存在迁移文件中,它们描述了如何进入新状态以及如何还原更改以恢复旧状态. 你将需要 Sequelize CLI. CLI支持迁移和项目引导. Sequelize 中的 Migration 是一个 javascript 文件,它导出两个函数 up 和 down,这些函数指示如何执行迁移和撤消它. 你可以手动定义这些功能,但不必手动调用它们; 它们将由 CLI 自动调用. 在这些函数中,你应该借助 sequelize.query 以及 Sequelize 提供给你的其他任何方法,简单地执行所需的任何查询. 除此之外,没有其他神奇的事情. 安装 CLI 要安装 Sequelize CLI,请执行以下操作： # using npm npm install --save-dev sequelize-cli # using yarn yarn add sequelize-cli --dev 有关详细信息,请参见 CLI GitHub 库. 项目启动 要创建一个空项目,你需要执行 init 命令 # using npm npx sequelize-cli init # using yarn yarn sequelize-cli init 这将创建以下文件夹 config, 包含配置文件,它告诉CLI如何连接数据库 models,包含你的项目的所有模型 migrations, 包含所有迁移文件 seeders, 包含所有种子文件 结构 在继续进行之前,我们需要告诉 CLI 如何连接到数据库. 为此,可以打开默认配置文件 config/config.json. 看起来像这样: { \"development\": { \"username\": \"root\", \"password\": null, \"database\": \"database_development\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\" }, \"test\": { \"username\": \"root\", \"password\": null, \"database\": \"database_production\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\" }, \"production\": { \"username\": \"root\", \"password\": null, \"database\": \"database_test\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\" } } 请注意,默认情况下,Sequelize CLI 假定使用 mysql. 如果你使用其他方言,则需要更改 \"dialect\" 参数的内容. 现在编辑此文件并设置正确的数据库凭据和方言.对象的键(例如 \"development\")用于 model/index.js 以匹配 process.env.NODE_ENV(当未定义时,默认值是 \"development\"). Sequelize 将为每个方言使用默认的连接端口(例如,对于postgres,它是端口5432). 如果需要指定其他端口,请使用 port 字段(默认情况下它不在 config/config.js 中,但你可以简单地添加它). 注意: 如果你的数据库还不存在,你可以调用 db:create 命令. 通过正确的访问,它将为你创建该数据库. 创建第一个模型(和迁移) 一旦你正确配置了CLI配置文件,你就可以首先创建迁移. 它像执行一个简单的命令一样简单. 我们将使用 model:generate 命令. 此命令需要两个选项 name: 模型的名称 attributes: 模型的属性列表 让我们创建一个名叫 User 的模型 # using npm npx sequelize-cli model:generate --name User --attributes firstName:string,lastName:string,email:string # using yarn yarn sequelize-cli model:generate --name User --attributes firstName:string,lastName:string,email:string 这将发生以下事情 在 models 文件夹中创建了一个 user 模型文件; 在 migrations 文件夹中创建了一个名字像 XXXXXXXXXXXXXX-create-user.js 的迁移文件. 注意: Sequelize 将只使用模型文件,它是表描述.另一边,迁移文件是该模型的更改,或更具体的是说 CLI 所使用的表. 处理迁移,如提交或日志,以进行数据库的某些更改. 运行迁移 直到这一步,CLI没有将任何东西插入数据库. 我们刚刚为我们的第一个模型 User 创建了必需的模型和迁移文件. 现在要在数据库中实际创建该表,需要运行 db:migrate 命令. # using npm npx sequelize-cli db:migrate # using yarn yarn sequelize-cli db:migrate 此命令将执行这些步骤 将在数据库中确保一个名为 SequelizeMeta 的表. 此表用于记录在当前数据库上运行的迁移 开始寻找尚未运行的任何迁移文件. 这可以通过检查 SequelizeMeta 表. 在这个例子中,它将运行我们在最后一步中创建的 XXXXXXXXXXXXXX-create-user.js 迁移,. 创建一个名为 Users 的表,其中包含其迁移文件中指定的所有列. 撤消迁移 现在我们的表已创建并保存在数据库中. 通过迁移,只需运行命令即可恢复为旧状态. 你可以使用 db:migrate:undo,这个命令将会恢复最近的迁移. # using npm npx sequelize-cli db:migrate:undo # using yarn yarn sequelize-cli db:migrate:undo 通过使用 db:migrate:undo:all 命令撤消所有迁移,可以恢复到初始状态. 你还可以通过将其名称传递到 --to 选项中来恢复到特定的迁移. # using npm npx sequelize-cli db:migrate:undo:all --to XXXXXXXXXXXXXX-create-posts.js # using yarn yarn sequelize-cli db:migrate:undo:all --to XXXXXXXXXXXXXX-create-posts.js 创建第一个种子 假设我们希望在默认情况下将一些数据插入到几个表中. 如果我们跟进前面的例子,我们可以考虑为 User 表创建演示用户. 要管理所有数据迁移,你可以使用 seeders. 种子文件是数据的一些变化,可用于使用样本数据或测试数据填充数据库表. 让我们创建一个种子文件,它会将一个演示用户添加到我们的 User 表中. # using npm npx sequelize-cli seed:generate --name demo-user # using yarn yarn sequelize-cli seed:generate --name demo-user 这个命令将会在 seeders 文件夹中创建一个种子文件.文件名看起来像是 XXXXXXXXXXXXXX-demo-user.js,它遵循相同的 up/down 语义,如迁移文件. 现在我们应该编辑这个文件,将演示用户插入User表. module.exports = { up: (queryInterface, Sequelize) => { return queryInterface.bulkInsert('Users', [{ firstName: 'John', lastName: 'Doe', email: 'example@example.com', createdAt: new Date(), updatedAt: new Date() }]); }, down: (queryInterface, Sequelize) => { return queryInterface.bulkDelete('Users', null, {}); } }; 运行种子 在上一步中,你创建了一个种子文件. 但它还没有保存到数据库. 为此,我们需要运行一个简单的命令. # using npm npx sequelize-cli db:seed:all # using yarn yarn sequelize-cli db:seed:all 这将执行该种子文件,你将有一个演示用户插入 User 表. 注意: 与使用 SequelizeMeta 表的迁移不同,Seeder 执行历史记录不会存储在任何地方. 如果你想更改此行为,请阅读 存储 部分 撤销种子 Seeders 如果使用了任何存储那么就可以被撤消. 有两个可用的命令 如果你想撤消最近的种子 # using npm npx sequelize-cli db:seed:undo # using yarn yarn sequelize-cli db:seed:undo 如果你想撤消特定的种子 # using npm npx sequelize-cli db:seed:undo --seed name-of-seed-as-in-data # using yarn yarn sequelize-cli db:seed:undo --seed name-of-seed-as-in-data 如果你想撤消所有的种子 # using npm npx sequelize-cli db:seed:undo:all # using yarn yarn sequelize-cli db:seed:undo:all 高级专题 以下框架显示了一个典型的迁移文件. module.exports = { up: (queryInterface, Sequelize) => { // 转变为新状态的逻辑 }, down: (queryInterface, Sequelize) => { // 恢复更改的逻辑 } } 我们可以使用 migration:generate 生成该文件. 这将在你的迁移文件夹中创建 xxx-migration-skeleton.js. # using npm npx sequelize-cli migration:generate --name migration-skeleton # using yarn yarn sequelize-cli migration:generate --name migration-skeleton 传递的 queryInterface 对象可以用来修改数据库. Sequelize 对象存储可用的数据类型,如 STRING 或 INTEGER. 函数 up 或 down 应该返回一个 Promise . 让我们来看一个例子 module.exports = { up: (queryInterface, Sequelize) => { return queryInterface.createTable('Person', { name: Sequelize.DataTypes.STRING, isBetaMember: { type: Sequelize.DataTypes.BOOLEAN, defaultValue: false, allowNull: false } }); }, down: (queryInterface, Sequelize) => { return queryInterface.dropTable('Person'); } }; 以下是一个迁移示例,该迁移使用自动管理的事务来在数据库中执行两次更改,以确保成功执行所有指令或在发生故障时回滚所有指令： module.exports = { up: (queryInterface, Sequelize) => { return queryInterface.sequelize.transaction(t => { return Promise.all([ queryInterface.addColumn('Person', 'petName', { type: Sequelize.DataTypes.STRING }, { transaction: t }), queryInterface.addColumn('Person', 'favoriteColor', { type: Sequelize.DataTypes.STRING, }, { transaction: t }) ]); }); }, down: (queryInterface, Sequelize) => { return queryInterface.sequelize.transaction(t => { return Promise.all([ queryInterface.removeColumn('Person', 'petName', { transaction: t }), queryInterface.removeColumn('Person', 'favoriteColor', { transaction: t }) ]); }); } }; 下一个是具有外键的迁移示例. 你可以使用 references 来指定外键: module.exports = { up: (queryInterface, Sequelize) => { return queryInterface.createTable('Person', { name: Sequelize.DataTypes.STRING, isBetaMember: { type: Sequelize.DataTypes.BOOLEAN, defaultValue: false, allowNull: false }, userId: { type: Sequelize.DataTypes.INTEGER, references: { model: { tableName: 'users', schema: 'schema' }, key: 'id' }, allowNull: false }, }); }, down: (queryInterface, Sequelize) => { return queryInterface.dropTable('Person'); } } 下一个是使用 async/await 的迁移示例, 其中你通过手动管理的事务在新列上创建唯一索引： module.exports = { async up(queryInterface, Sequelize) { const transaction = await queryInterface.sequelize.transaction(); try { await queryInterface.addColumn( 'Person', 'petName', { type: Sequelize.DataTypes.STRING, }, { transaction } ); await queryInterface.addIndex( 'Person', 'petName', { fields: 'petName', unique: true, transaction, } ); await transaction.commit(); } catch (err) { await transaction.rollback(); throw err; } }, async down(queryInterface, Sequelize) { const transaction = await queryInterface.sequelize.transaction(); try { await queryInterface.removeColumn('Person', 'petName', { transaction }); await transaction.commit(); } catch (err) { await transaction.rollback(); throw err; } } }; 下一个示例, 该迁移创建具多个字段组成的唯一索引, 该索引允许一个关系存在多次, 但只有一个满足条件: module.exports = { up: (queryInterface, Sequelize) => { queryInterface.createTable('Person', { name: Sequelize.DataTypes.STRING, bool: { type: Sequelize.DataTypes.BOOLEAN, defaultValue: false } }).then((queryInterface, Sequelize) => { queryInterface.addIndex( 'Person', ['name', 'bool'], { indicesType: 'UNIQUE', where: { bool : 'true' }, } ); }); }, down: (queryInterface, Sequelize) => { return queryInterface.dropTable('Person'); } } .sequelizerc 文件 这是一个特殊的配置文件. 它允许你指定通常作为参数传递给CLI的各种选项: env: 在其中运行命令的环境 config: 配置文件的路径 options-path: 带有其他参数的 JSON 文件的路径 migrations-path: migrations 文件夹的路径 seeders-path: seeders 文件夹的路径 models-path: models 文件夹的路径 url: 要使用的数据库连接字符串. 替代使用 --config 文件 debug: 可用时显示各种调试信息 在某些情况下,你可以使用它: 你想要覆盖到 migrations, models, seeders 或 config 文件夹的路径. 你想要重命名 config.json 成为别的名字比如 database.json 还有更多的, 让我们看一下如何使用这个文件进行自定义配置. 首先,让我们在项目的根目录中创建 .sequelizerc 文件,其内容如下： // .sequelizerc const path = require('path'); module.exports = { 'config': path.resolve('config', 'database.json'), 'models-path': path.resolve('db', 'models'), 'seeders-path': path.resolve('db', 'seeders'), 'migrations-path': path.resolve('db', 'migrations') }; 通过这个配置你告诉CLI: 使用 config/database.json 文件来配置设置; 使用 db/models 作为模型文件夹; 使用 db/seeders 作为种子文件夹; 使用 db/migrations 作为迁移文件夹; 动态配置 默认情况下,配置文件是一个名为 config.json 的 JSON 文件. 但是有时你需要动态配置,例如访问环境变量或执行其他代码来确定配置. 值得庆幸的是,Sequelize CLI 可以从 .json 和 .js 文件中读取. 可以使用 .sequelizerc 文件来设置. 你只需提供 .js 文件的路径作为导出对象的 config 参数即可： const path = require('path'); module.exports = { 'config': path.resolve('config', 'config.js') } 现在,Sequelize CLI 将加载 config/config.js 以获取配置参数. 一个 config/config.js 文件的例子 const fs = require('fs'); module.exports = { development: { username: 'database_dev', password: 'database_dev', database: 'database_dev', host: '127.0.0.1', port: 3306, dialect: 'mysql', dialectOptions: { bigNumberStrings: true } }, test: { username: process.env.CI_DB_USERNAME, password: process.env.CI_DB_PASSWORD, database: process.env.CI_DB_NAME, host: '127.0.0.1', port: 3306, dialect: 'mysql', dialectOptions: { bigNumberStrings: true } }, production: { username: process.env.PROD_DB_USERNAME, password: process.env.PROD_DB_PASSWORD, database: process.env.PROD_DB_NAME, host: process.env.PROD_DB_HOSTNAME, port: process.env.PROD_DB_PORT, dialect: 'mysql', dialectOptions: { bigNumberStrings: true, ssl: { ca: fs.readFileSync(__dirname + '/mysql-ca-main.crt') } } } }; 上面的示例还显示了如何向配置中添加自定义方言参数. 使用 Babel 为了在你的迁移和 seeder 中实现更现代的构造,你可以简单地安装 babel-register 并在 .sequelizerc 开始时 require 它： # using npm npm i --save-dev babel-register # using yarn yarn add babel-register --dev // .sequelizerc require(\"babel-register\"); const path = require('path'); module.exports = { 'config': path.resolve('config', 'config.json'), 'models-path': path.resolve('models'), 'seeders-path': path.resolve('seeders'), 'migrations-path': path.resolve('migrations') } 当然,结果将取决于你的 babel 配置(例如在 .babelrc 文件中). 在babeljs.io了解更多信息 安全提示 使用环境变量进行配置设置. 这是因为诸如密码之类的机密绝不应该是源代码的一部分(尤其是不要提交给版本控制). 存储 你可以使用三种类型的存储：sequelize,json和none. sequelize : 将迁移和种子存储在 sequelize 数据库的表中 json : 将迁移和种子存储在 json 文件中 none : 不存储任何迁移/种子 迁移存储 默认情况下,CLI 将在数据库中创建一个名为 SequelizeMeta 的表,其中包含每个执行的迁移的条目. 要更改此行为,可以将三个参数添加到配置文件中. 使用 migrationStorage,你可以选择用于迁移的存储类型. 如果选择 json,则可以使用 migrationStoragePath 指定文件的路径,否则 CLI 将写入文件 sequelize-meta.json. 如果你想使用 sequelize 将信息保留在数据库中,但又想使用其他表,则可以使用 migrationStorageTableName 来更改表名. 你还可以通过提供 migrationStorageTableSchema 属性来为 SequelizeMeta 表定义不同的架构. { \"development\": { \"username\": \"root\", \"password\": null, \"database\": \"database_development\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\", // 使用其他存储类型. 默认: sequelize \"migrationStorage\": \"json\", // 使用其他文件名. 默认: sequelize-meta.json \"migrationStoragePath\": \"sequelizeMeta.json\", // 使用其他表格名称. 默认: SequelizeMeta \"migrationStorageTableName\": \"sequelize_meta\", // 对 SequelizeMeta 表使用其他架构 \"migrationStorageTableSchema\": \"custom_schema\" } } Note: 不建议将 none 存储作为迁移存储. 如果你决定使用它,请注意没有任何迁移进行或未运行的记录的含义. 种子储存 默认情况下,CLI 不会保存任何已执行的种子. 如果选择更改此行为(！),则可以在配置文件中使用 seederStorage 来更改存储类型. 如果选择 json,则可以使用 seederStoragePath 指定文件的路径,否则 CLI 将写入文件 sequelize-data.json. 如果要使用 sequelize 将信息保留在数据库中,则可以使用 seederStorageTableName 指定表名,否则它将默认为 SequelizeData. { \"development\": { \"username\": \"root\", \"password\": null, \"database\": \"database_development\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\", // 使用其他存储. 默认: none \"seederStorage\": \"json\", // 使用其他文件名称. 默认: sequelize-data.json \"seederStoragePath\": \"sequelizeData.json\", // 使用其他表格名称. 默认: SequelizeData \"seederStorageTableName\": \"sequelize_data\" } } 配置连接字符串 配置连接字符串作为配置文件定义数据库的 --config 参数的替代方法,可以使用 --url 参数来传递连接字符串. 例如： # using npm npx sequelize-cli db:migrate --url 'mysql://root:password@mysql_host.com/database_name' # using yarn yarn sequelize-cli db:migrate --url 'mysql://root:password@mysql_host.com/database_name' 程序用法 程序用法 Sequelize 有一个名为 umzug 的姊妹库,用于以编程方式处理迁移任务的执行和日志记录. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/typescript.html":{"url":"other-topics/typescript.html","title":"TypeScript","keywords":"","body":"TypeScript Sequelize 提供了自己的 TypeScript 定义. 请注意, 仅支持 TypeScript >= 4.1. 我们对 TypeScript 的支持不遵循 SemVer. 我们将支持 TypeScript 版本至少一年, 之后它们可能会在 SemVer MINOR 版本中被删除. 由于 Sequelize 严重依赖于运行时属性分配, 因此 TypeScript 无法立即开箱即用. 为了使模型可用, 需要大量的手动类型声明. 安装 为了避免非 TS 用户的安装膨胀,你必须手动安装以下键入程序包: @types/node (在 node 项目中这是通常是必须的) @types/validator 使用 重要: 您必须在类属性类型上使用 declare 以确保 TypeScript 不会触发这些类属性. 参阅 公共类字段的注意事项 Sequelize Models 接受两种通用类型来定义模型的属性和创建属性是什么样的: import { Model, Optional } from 'sequelize'; // We don't recommend doing this. Read on for the new way of declaring Model typings. type UserAttributes = { id: number, name: string, // other attributes... }; // we're telling the Model that 'id' is optional // when creating an instance of the model (such as using Model.create()). type UserCreationAttributes = Optional; class User extends Model { declare id: number; declare string: number; // other attributes... } 这个解决方案很冗长. Sequelize >=6.14.0 提供了新的实用程序类型, 将大大减少数量 必需的样板: InferAttributes 和 InferCreationAttributes. 他们将提取属性类型 直接来自模型: import { Model, InferAttributes, InferCreationAttributes, CreationOptional } from 'sequelize'; // order of InferAttributes & InferCreationAttributes is important. class User extends Model, InferCreationAttributes> { // 'CreationOptional' is a special type that marks the field as optional // when creating an instance of the model (such as using Model.create()). declare id: CreationOptional; declare string: number; // other attributes... } 关于 InferAttributes 和 InferCreationAttributes 工作需要了解的重要事项: 它们将选择类的所有声明属性，除了: 静态字段和方法. 方法（任何类型为函数的东西）. 类型使用铭记类型 NonAttribute 的那些. 像这样使用 AttributesOf 排除的那些: InferAttributes. 由 Model 超类声明的那些（但不是中间类！）. 如果您的属性之一与 Model 的属性之一同名, 请更改其名称. 无论如何, 这样做可能会导致问题. Getter & setter 不会被自动排除. 将它们的 return / parameter 类型设置为 NonAttribute, 或将它们添加到 omit 以排除它们. InferCreationAttributes 的工作方式与 AttributesOf 相同, 但有一个例外: 使用 CreationOptional 类型键入的属性将被标记为可选. 您只需要在类实例字段或 getter 上使用 CreationOptional 和 NonAttribute. 对属性进行严格类型检查的最小 TypeScript 项目示例: import { Association, DataTypes, HasManyAddAssociationMixin, HasManyCountAssociationsMixin, HasManyCreateAssociationMixin, HasManyGetAssociationsMixin, HasManyHasAssociationMixin, HasManySetAssociationsMixin, HasManyAddAssociationsMixin, HasManyHasAssociationsMixin, HasManyRemoveAssociationMixin, HasManyRemoveAssociationsMixin, Model, ModelDefined, Optional, Sequelize, InferAttributes, InferCreationAttributes, CreationOptional, NonAttribute } from 'sequelize'; const sequelize = new Sequelize('mysql://root:asd123@localhost:3306/mydb'); // 'projects' is excluded as it's not an attribute, it's an association. class User extends Model, InferCreationAttributes> { // id can be undefined during creation when using `autoIncrement` declare id: CreationOptional; declare name: string; declare preferredName: string | null; // for nullable fields // timestamps! // createdAt can be undefined during creation declare createdAt: CreationOptional; // updatedAt can be undefined during creation declare updatedAt: CreationOptional; // Since TS cannot determine model association at compile time // we have to declare them here purely virtually // these will not exist until `Model.init` was called. declare getProjects: HasManyGetAssociationsMixin; // Note the null assertions! declare addProject: HasManyAddAssociationMixin; declare addProjects: HasManyAddAssociationsMixin; declare setProjects: HasManySetAssociationsMixin; declare removeProject: HasManyRemoveAssociationMixin; declare removeProjects: HasManyRemoveAssociationsMixin; declare hasProject: HasManyHasAssociationMixin; declare hasProjects: HasManyHasAssociationsMixin; declare countProjects: HasManyCountAssociationsMixin; declare createProject: HasManyCreateAssociationMixin; // You can also pre-declare possible inclusions, these will only be populated if you // actively include a relation. declare projects?: NonAttribute; // Note this is optional since it's only populated when explicitly requested in code // getters that are not attributes should be tagged using NonAttribute // to remove them from the model's Attribute Typings. get fullName(): NonAttribute { return this.name; } declare static associations: { projects: Association; }; } class Project extends Model, InferCreationAttributes > { // id can be undefined during creation when using `autoIncrement` declare id: CreationOptional; declare ownerId: number; declare name: string; // `owner` is an eagerly-loaded association. // We tag it as `NonAttribute` declare owner?: NonAttribute; // createdAt can be undefined during creation declare createdAt: CreationOptional; // updatedAt can be undefined during creation declare updatedAt: CreationOptional; } class Address extends Model, InferCreationAttributes > { declare userId: number; declare address: string; // createdAt can be undefined during creation declare createdAt: CreationOptional; // updatedAt can be undefined during creation declare updatedAt: CreationOptional; } Project.init( { id: { type: DataTypes.INTEGER.UNSIGNED, autoIncrement: true, primaryKey: true }, ownerId: { type: DataTypes.INTEGER.UNSIGNED, allowNull: false }, name: { type: new DataTypes.STRING(128), allowNull: false }, createdAt: DataTypes.DATE, updatedAt: DataTypes.DATE, }, { sequelize, tableName: 'projects' } ); User.init( { id: { type: DataTypes.INTEGER.UNSIGNED, autoIncrement: true, primaryKey: true }, name: { type: new DataTypes.STRING(128), allowNull: false }, preferredName: { type: new DataTypes.STRING(128), allowNull: true }, createdAt: DataTypes.DATE, updatedAt: DataTypes.DATE, }, { tableName: 'users', sequelize // passing the `sequelize` instance is required } ); Address.init( { userId: { type: DataTypes.INTEGER.UNSIGNED }, address: { type: new DataTypes.STRING(128), allowNull: false }, createdAt: DataTypes.DATE, updatedAt: DataTypes.DATE, }, { tableName: 'address', sequelize // passing the `sequelize` instance is required } ); // You can also define modules in a functional way interface NoteAttributes { id: number; title: string; content: string; } // You can also set multiple attributes optional at once type NoteCreationAttributes = Optional; // And with a functional approach defining a module looks like this const Note: ModelDefined = sequelize.define( 'Note', { id: { type: DataTypes.INTEGER.UNSIGNED, autoIncrement: true, primaryKey: true }, title: { type: new DataTypes.STRING(64), defaultValue: 'Unnamed Note' }, content: { type: new DataTypes.STRING(4096), allowNull: false } }, { tableName: 'notes' } ); // Here we associate which actually populates out pre-declared `association` static and other methods. User.hasMany(Project, { sourceKey: 'id', foreignKey: 'ownerId', as: 'projects' // this determines the name in `associations`! }); Address.belongsTo(User, { targetKey: 'id' }); User.hasOne(Address, { sourceKey: 'id' }); async function doStuffWithUser() { const newUser = await User.create({ name: 'Johnny', preferredName: 'John', }); console.log(newUser.id, newUser.name, newUser.preferredName); const project = await newUser.createProject({ name: 'first!' }); const ourUser = await User.findByPk(1, { include: [User.associations.projects], rejectOnEmpty: true // Specifying true here removes `null` from the return type! }); // Note the `!` null assertion since TS can't know if we included // the model or not console.log(ourUser.projects![0].name); } (async () => { await sequelize.sync(); await doStuffWithUser(); })(); 使用非严格类型 Sequelize v5 的类型允许你定义模型而无需指定属性类型. 对于向后兼容以及在你觉得对属性进行严格检查是不值得的情况下, 这仍然是可行的. import { Sequelize, Model, DataTypes } from 'sequelize'; const sequelize = new Sequelize('mysql://root:asd123@localhost:3306/mydb'); class User extends Model { declare id: number; declare name: string; declare preferredName: string | null; } User.init( { id: { type: DataTypes.INTEGER.UNSIGNED, autoIncrement: true, primaryKey: true, }, name: { type: new DataTypes.STRING(128), allowNull: false, }, preferredName: { type: new DataTypes.STRING(128), allowNull: true, }, }, { tableName: 'users', sequelize, // passing the `sequelize` instance is required }, ); async function doStuffWithUserModel() { const newUser = await User.create({ name: 'Johnny', preferredName: 'John', }); console.log(newUser.id, newUser.name, newUser.preferredName); const foundUser = await User.findOne({ where: { name: 'Johnny' } }); if (foundUser === null) return; console.log(foundUser.name); } 使用 sequelize.define 在 v5 之前的 Sequelize 版本中, 定义模型的默认方式涉及使用 sequelize.define. 仍然可以使用它来定义模型, 也可以使用接口在这些模型中添加类型. import { Sequelize, Model, DataTypes, Optional } from 'sequelize'; const sequelize = new Sequelize('mysql://root:asd123@localhost:3306/mydb'); // We recommend you declare an interface for the attributes, for stricter typechecking interface UserAttributes { id: number; name: string; } // Some fields are optional when calling UserModel.create() or UserModel.build() interface UserCreationAttributes extends Optional {} // We need to declare an interface for our model that is basically what our class would be interface UserInstance extends Model, UserAttributes {} const UserModel = sequelize.define('User', { id: { primaryKey: true, type: DataTypes.INTEGER.UNSIGNED, }, name: { type: DataTypes.STRING, } }); async function doStuff() { const instance = await UserModel.findByPk(1, { rejectOnEmpty: true, }); console.log(instance.id); } 如果你对模型上非严格的属性检查命令感到满意，则可以通过定义 Instance 来扩展 Model 而无需泛型类型中的任何属性, 从而节省一些代码. import { Sequelize, Model, DataTypes } from 'sequelize'; const sequelize = new Sequelize('mysql://root:asd123@localhost:3306/mydb'); // We need to declare an interface for our model that is basically what our class would be interface UserInstance extends Model { id: number; name: string; } const UserModel = sequelize.define('User', { id: { primaryKey: true, type: DataTypes.INTEGER.UNSIGNED, }, name: { type: DataTypes.STRING, }, }); async function doStuff() { const instance = await UserModel.findByPk(1, { rejectOnEmpty: true, }); console.log(instance.id); } 实用程序类型 请求模型类 ModelStatic 旨在用于键入模型 class. 以下是请求模型类并返回该类中定义的主键列表的实用方法示例: import { ModelStatic, ModelAttributeColumnOptions, Model, InferAttributes, InferCreationAttributes, CreationOptional } from 'sequelize'; /** * Returns the list of attributes that are part of the model's primary key. */ export function getPrimaryKeyAttributes(model: ModelStatic): ModelAttributeColumnOptions[] { const attributes: ModelAttributeColumnOptions[] = []; for (const attribute of Object.values(model.rawAttributes)) { if (attribute.primaryKey) { attributes.push(attribute); } } return attributes; } class User extends Model, InferCreationAttributes> { id: CreationOptional; } User.init({ id: { type: DataTypes.INTEGER.UNSIGNED, autoIncrement: true, primaryKey: true }, }, { sequelize }); const primaryAttributes = getPrimaryKeyAttributes(User); 获取模型的属性 如果您需要访问给定模型的属性列表, 你需要使用 Attributes 和 CreationAttributes. 它们将返回作为参数传递的模型的属性(和创建属性). 不要将它们与 InferAttributes 和 InferCreationAttributes 混淆. 这两种实用程序类型应该只被使用 在模型的定义中自动从模型的公共类字段创建属性列表. 它们仅适用于基于类的模型定义(使用 Model.init 时). Attributes 和 CreationAttributes 将返回任何模型的属性列表, 无论它们是如何创建的(无论是 Model.init 还是 Sequelize#define). 这是一个请求模型类和属性名称的实用函数示例; 并返回相应的属性元数据. import { ModelStatic, ModelAttributeColumnOptions, Model, InferAttributes, InferCreationAttributes, CreationOptional, Attributes } from 'sequelize'; export function getAttributeMetadata(model: ModelStatic, attributeName: keyof Attributes): ModelAttributeColumnOptions { const attribute = model.rawAttributes[attributeName]; if (attribute == null) { throw new Error(`Attribute ${attributeName} does not exist on model ${model.name}`); } return attribute; } class User extends Model, InferCreationAttributes> { id: CreationOptional; } User.init({ id: { type: DataTypes.INTEGER.UNSIGNED, autoIncrement: true, primaryKey: true }, }, { sequelize }); const idAttributeMeta = getAttributeMetadata(User, 'id'); // works! // @ts-expect-error const nameAttributeMeta = getAttributeMetadata(User, 'name'); // fails because 'name' is not an attribute of User 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "},"other-topics/resources.html":{"url":"other-topics/resources.html","title":"Resources - 资源","keywords":"","body":"Resources - 资源 Addons & Plugins ACL ssacl ssacl-attribute-roles SequelizeGuard - Role, Permission based Authorization for Sequelize. Auto Code Generation & Scaffolding meteor modeler - Desktop tool for visual definition of Sequelize models and asssociations. sequelize-ui - Online tool for building models, relations and more. sequelizer - A GUI Desktop App for generating Sequelize models. Support for Mysql, Mariadb, Postgres, Sqlite, Mssql. sequelize-auto Generating models for SequelizeJS via the command line is another choice. pg-generator - Auto generate/scaffold Sequelize models for PostgreSQL database. sequelizejs-decorators decorators for composing sequelize models Autoloader sequelize-autoload - An autoloader for Sequelize, inspired by PSR-0 and PSR-4. Bcrypt sequelize-bcrypt - Utility to integrate bcrypt into sequelize models Caching sequelize-transparent-cache Filters sequelize-transforms - Add configurable attribute transforms. Fixtures / mock data Fixer Sequelize-fixtures Sequelize-fixture Hierarchies sequelize-hierarchy - Nested hierarchies for Sequelize. Historical records / Time travel sequelize-temporal - Temporal tables (aka historical records) Joi sequelize-joi - Allows specifying Joi validation schema for model attributes in Sequelize. Migrations umzug Slugification sequelize-slugify - Add slugs to sequelize models Tokens sequelize-tokenify - Add unique tokens to sequelize models Miscellaneous sequelize-deep-update - Update a sequelize instance and its included associated instances with new properties. sequelize-noupdate-attributes - Adds no update/readonly attributes support to models. sqlcommenter-sequelize A sqlcommenter plugin with support for Sequelize to augment SQL statements with comments that can be used later to correlate application code with SQL statements. 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-25 18:10:52 "}}